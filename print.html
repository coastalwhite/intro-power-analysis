<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Power analysis Introductory Walkthrough</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="preparing.html"><strong aria-hidden="true">2.</strong> Preparing your environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="preparing/python-pip.html"><strong aria-hidden="true">2.1.</strong> Python and Pip</a></li><li class="chapter-item expanded "><a href="preparing/chipwhisperer.html"><strong aria-hidden="true">2.2.</strong> ChipWhisperer</a></li><li class="chapter-item expanded "><a href="preparing/toolchains.html"><strong aria-hidden="true">2.3.</strong> Compiling your own algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="rsa.html"><strong aria-hidden="true">3.</strong> A case study: RSA</a></li><li class="chapter-item expanded "><a href="aes.html"><strong aria-hidden="true">4.</strong> Breaking AES</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="aes/workings.html"><strong aria-hidden="true">4.1.</strong> How AES works</a></li><li class="chapter-item expanded "><a href="aes/capture.html"><strong aria-hidden="true">4.2.</strong> Capturing multiple traces</a></li><li class="chapter-item expanded "><a href="aes/modeling.html"><strong aria-hidden="true">4.3.</strong> Modeling AES</a></li><li class="chapter-item expanded "><a href="aes/manual-analysis.html"><strong aria-hidden="true">4.4.</strong> Manual analysis</a></li><li class="chapter-item expanded "><a href="aes/pearson.html"><strong aria-hidden="true">4.5.</strong> Pearson correlation</a></li><li class="chapter-item expanded "><a href="aes/entire.html"><strong aria-hidden="true">4.6.</strong> Automatically cracking an entire key</a></li><li class="chapter-item expanded "><a href="aes/optimization.html"><strong aria-hidden="true">4.7.</strong> Sidenote: Optimizing our algorithm</a></li><li class="chapter-item expanded "><a href="aes/exercises.html"><strong aria-hidden="true">4.8.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="assignment.html"><strong aria-hidden="true">5.</strong> Assignment</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Power analysis Introductory Walkthrough</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/coastalwhite/intro-power-analysis" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="power-analysis-introductory-walkthrough"><a class="header" href="#power-analysis-introductory-walkthrough">Power Analysis Introductory Walkthrough</a></h1>
<p>IT Security has many fields and layers, all of which aim to investigate how to
break and protect the cores principles of information security which are confidentiality,
integrity and availability. One of these fields is Hardware Security. Here the
focus lies on the how the physical parts of our electronics handle these
principles and what we can do to break and protect them.</p>
<p>One of the techniques within hardware security which aims break confidentiality
is power analysis. Power analysis looks at the power consumption of hardware in
order to make statements about the calculations done within a computer. Some
calculations require a higher wattage then other calculations.</p>
<p>Take a look at the following picture. If we know that the following <em>Figure 1</em>
records the a sequence of two different computations - namely, squaring and
taking a product - and we also know that squaring takes marginally less time
than taking a product in this case. You could maybe identify where the power
trace is taking a product and where the trace is squaring a number.</p>
<p><img src="./assets/power_analysis.png" alt="Power Analysis of RSA" /></p>
<p><em>Figure 1: Power Trace of a RSA encryption by
<a href="https://en.wikipedia.org/wiki/Power_analysis#/media/File:Power_attack_full.png">Audriusa</a>
(GPFL)</em></p>
<h2 id="what-do-you-need-for-this-walkthrough"><a class="header" href="#what-do-you-need-for-this-walkthrough">What do you need for this walkthrough</a></h2>
<p>This walkthrough is meant to be a introduction into both power analysis and
using the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework.
It expects you to have some basic knowledge of Python (and probably C or Rust).
It also helps to be comfortable with the terminal/shell. This walkthrough is
not about programming or the shell, however, and most of what is discussed could
be followed along with, even if you have very little programming experience.</p>
<p>Furthermore, if you plan on doing your own traces, you will need a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board. This
walkthrough will provide predefined data sets, so you can do analysis without
doing the traces yourself. This could save you from buying a ChipWhisperer
board. It is, however, highly recommended to do some traces yourself. If you are
looking at buying a ChipWhisperer board and don't know what to use, this
walkthrough is based on the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite
ARM</a> variant. It is a relatively
cheap all-in-one solution.</p>
<h2 id="chipwhisperer"><a class="header" href="#chipwhisperer">ChipWhisperer</a></h2>
<p>Normally, to make these measurements, you need a lot of expensive equipment.
Equipment such as multimeters, oscilloscopes, different microcontrollers,
connectors, etc. This is where the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer
framework</a> comes in. The
ChipWhisperer framework provides microcontrollers to test and run you
algorithms on, which are referred to as <strong>targets</strong>. But also provides
measurement devices, which when put together with a target is referred to as a
<strong>scope</strong>. The ChipWhisperer goes further than a playground and can be used in
real world environments, which makes an ideal framework to learn power analysis
with.</p>
<h1 id="preparing-your-environment"><a class="header" href="#preparing-your-environment">Preparing your environment</a></h1>
<blockquote>
<p><strong>Preliminaries</strong></p>
<p>This chapter expects the reader to have a personal computer (running a modern
version of Windows, macOS or a commonly used GNU/Linux distribution) to which
one has installation permissions. Especially for macOS and GNU/Linux, a basic
understanding of the shell is recommended.</p>
</blockquote>
<p>Although working with the
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> requires little
setup, it has some prerequisites. Apart from from the usual text editor/IDE
(VSCode, IntelliJ, VIM, Emacs, etc.) and Python, we need to install some
libraries and toolchains. What we need to install also depends on what we want
to achieve with this walkthrough. So the next few sections are going to take you
through some of the common necessities.</p>
<h1 id="python-and-pip"><a class="header" href="#python-and-pip">Python and Pip</a></h1>
<p>As previously mentioned, we are going to be heavily relying on Python to do most
of our measurements. We are also going to do some data analysis using Python.
Therefore, we need to install Python along with some packages for it. These
packages being <a href="https://numpy.org/"><code>numpy</code></a>,
<a href="https://matplotlib.org/"><code>matplotlib</code></a> and
<a href="https://github.com/tqdm/tqdm"><code>tqdm</code></a>.</p>
<h2 id="installing-python"><a class="header" href="#installing-python">Installing Python</a></h2>
<p>The code provided by this walkthrough uses <strong>Python 3</strong> and will <strong>NOT</strong> work on
Python 2. Installing Python is a platform dependent workflow. Here are some
common operating systems, for other operating systems a simple <a href="https://letmegooglethat.com/?q=installing+python">Google
search</a> or a glance at
<a href="https://www.python.org/">Python.org</a> should do the trick.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>For Windows, download and run the <em>Windows installer</em> from
<a href="https://www.python.org/downloads/windows/">Python.org</a>. For most people the
64-bit version should be the one.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>For Mac, you can either install python using <a href="https://brew.sh/">Homebrew</a> with
the
following shell command.</p>
<pre><code class="language-bash">brew install python3
</code></pre>
<p>Or you can install Python via the <a href="https://www.python.org/downloads/mac-osx/">macOS
Installer</a>. Depending on whether on
whether you own a Intel-based macOS device or a ARM-based macOS, you can select
the 64-bit Intel or 64-bit universal2 installer, respectively.</p>
<h3 id="gnulinux"><a class="header" href="#gnulinux">GNU/Linux</a></h3>
<p>For <strong>Debian</strong> based systems, including Ubuntu, you can use the following commands.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install python3 python3-pip
</code></pre>
<p>For <strong>ArchLinux</strong> based systems, including Manjaro, you can use the following
command.</p>
<pre><code class="language-bash">sudo pacman -S python python-pip
</code></pre>
<h3 id="validating-your-installation"><a class="header" href="#validating-your-installation">Validating your installation</a></h3>
<p>To check whether your installation was successful, restart your shell and run
the following command.</p>
<pre><code class="language-bash">python3 --version
</code></pre>
<p>For most installations, this should have also installed <code>pip</code>. We can verify
this with.</p>
<pre><code class="language-bash">pip3 help
</code></pre>
<h2 id="numpy"><a class="header" href="#numpy">NumPy</a></h2>
<p>One of the most common packages used in Python is the
<a href="https://numpy.org/">NumPy</a> package. We are also going to be using it here to do
some data transformations. To install NumPy we can use PIP.</p>
<pre><code class="language-bash">pip install numpy
</code></pre>
<h2 id="pyplot"><a class="header" href="#pyplot">PyPlot</a></h2>
<p>With our data it may be handy to plot our data. Most of the plots have a
provided example, however. This package is therefore recommended, but optional.
Installing is also via PIP.</p>
<pre><code class="language-bash">python -m pip install -U matplotlib
</code></pre>
<h2 id="tqdm"><a class="header" href="#tqdm">TQDM</a></h2>
<p>To have a better overview of the progress our calculations are making, this
walkthrough uses the progress bars from <a href="https://github.com/tqdm/tqdm">TQDM</a>.
This is also optional, but indeed very handy. Installation can be done via PIP.</p>
<pre><code class="language-bash">pip install tqdm
</code></pre>
<h1 id="chipwhisperer-1"><a class="header" href="#chipwhisperer-1">ChipWhisperer</a></h1>
<p>The ChipWhisperer framework has a Python library to interact with its devices.
This library is definitely a necessity if you plan on doing your own traces.</p>
<h2 id="installing-the-dependencies"><a class="header" href="#installing-the-dependencies">Installing the dependencies</a></h2>
<p>The ChipWhisperer python library has some dependencies. Mainly, these
dependencies are <code>libusb</code> and <code>make</code>. Let us go over the different operating
systems and what needs to be done there.</p>
<blockquote>
<p><strong>Note:</strong> If something here is not working correctly, one can refer back to
<a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html">this</a>
documentation page.</p>
</blockquote>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>For <strong>Windows</strong>, we mainly need to install <code>make</code>. There are multiple ways to do
this. I suggest installing <a href="https://letmegooglethat.com/?q=MinGW">MinGW</a> and
adding <code>MinGW\msys\1.0\bin</code> to your <code>PATH</code> environment variable.</p>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p>For <strong>macOS</strong>, <code>make</code> should already be installed. To install <code>libusb</code>, we can
use <a href="https://brew.sh/">Homebrew</a>.</p>
<pre><code class="language-bash">brew install libusb
</code></pre>
<h3 id="gnulinux-1"><a class="header" href="#gnulinux-1">GNU/Linux</a></h3>
<p>For <strong>Debian</strong> based systems, including Ubuntu, we can install both <code>make</code> and
<code>libusb</code> using the following command.</p>
<pre><code class="language-bash">sudo apt install libusb-dev make
</code></pre>
<p>For <strong>ArchLinux</strong> based systems, including Manjaro, we can install both <code>make</code>
and <code>libusb</code> using the following command.</p>
<pre><code class="language-bash">sudo pacman -S libusb make
</code></pre>
<h2 id="installing-the-python-library"><a class="header" href="#installing-the-python-library">Installing the python library</a></h2>
<p>To install the ChipWhisperer, we can use PIP. We install it with the following
command.</p>
<pre><code class="language-bash">pip install chipwhisperer
</code></pre>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying installation</a></h2>
<p>To verify that the installation succeeded, we can start python3 in interactive
mode using the <code>python3</code> shell command. Then we should see something such as the
following.</p>
<pre><code class="language-text">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>We can use the following python code to attempt to import the chipwhisperer
python library.</p>
<pre><code class="language-python3">import chipwhisperer as cw
</code></pre>
<p>If we don't receive any error messages, we have succesfully installed the
ChipWhisperer python library!</p>
<h2 id="note-for-gnulinux-users"><a class="header" href="#note-for-gnulinux-users">Note for GNU/Linux users</a></h2>
<p>When we are going to start doing traces, one might run into a <strong>permissions</strong> error.
This has to do with the <code>udev</code> rules. How to solve this, refer to the
<a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#hardware-drivers">ChipWhisperer
docs</a>.
This should solve having to run everything with <code>sudo</code>, which is not preferred.</p>
<h1 id="compiling-your-own-algorithms"><a class="header" href="#compiling-your-own-algorithms">Compiling your own algorithms</a></h1>
<p>This walkthrough provides most of the precompiled code you might need. However,
in order to do some of the provided exercises and do some experimentation
yourself, you might want to compile some algorithm. To do this, there are two
things we need. The toolchain to compile to our specific microprocessor
architecture and the source code to compile.</p>
<h2 id="toolchains"><a class="header" href="#toolchains">Toolchains</a></h2>
<p>In order to compile code which is usable for our specific microprocessor
architecture, we need to toolchain for that architecture. As said in the
<a href="preparing/../intro.html">introduction chapter</a>, this walkthrough is using the CW Lite Arm
variant and therefore here we will show how to install the ARM toolchain. For
other toolchains, have a look at the <a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#compilers">ChipWhisperer
documentation</a>.</p>
<h2 id="installing-the-arm-toolchain"><a class="header" href="#installing-the-arm-toolchain">Installing the ARM toolchain</a></h2>
<p>Information on the ARM can be found
<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">here</a>.</p>
<h3 id="windows-and-macos"><a class="header" href="#windows-and-macos">Windows and macOS</a></h3>
<p>For Windows and macOS, the installer on the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM developer
website</a>
should be enough to install the ARM embedded toolchain.</p>
<h3 id="gnulinux-2"><a class="header" href="#gnulinux-2">GNU/Linux</a></h3>
<p>For <strong>Debian</strong> based systems, including Ubuntu, we can use the following command
to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo apt install gcc-arm-none-eabi
</code></pre>
<p>For <strong>ArchLinux</strong> based systems, including Manjaro, we can use the following
command to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo pacman -S arm-none-eabi-gcc
</code></pre>
<h2 id="compiling-binaries"><a class="header" href="#compiling-binaries">Compiling binaries</a></h2>
<p>With the proper toolchain installed, we can compile binaries to be used on our
ChipWhisperer targets. Take a look at <a href="https://github.com/coastalwhite/simpleserial-c-template">Simpleserial
Template</a> on how to
create and compile your own binaries. Or have a look at <a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware">the ChipWhisperer
GitHub
repository</a>
for some examples.</p>
<blockquote>
<p><strong>Note:</strong> SimpleSerial is the protocol ChipWhisperer has defined to describe
communicating between the host machine (e.g. a laptop) and the target. Some
documentation on it can be found
<a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">here</a>.</p>
</blockquote>
<h1 id="a-case-study-rsa"><a class="header" href="#a-case-study-rsa">A case study: RSA</a></h1>
<p>RSA is an encryption algorithm that is used in a lot of places. That little
padlock in your browser; it is powered by RSA. Programming RSA is reasonably
simply, but the mathematics behind it can prove to be really though. Luckily,
there is no need to dive into too much depth to crack RSA using Simple Power
Analysis. In the chapter on AES, we will go a bit deeper into cache based
side-channel attacks, why they work exactly and how to perform them on the
ChipWhisperer. This chapter is going to skip over a few of the specifics to
create a better overview of our method and goals.</p>
<h2 id="what-is-rsa"><a class="header" href="#what-is-rsa">What is RSA?</a></h2>
<p>RSA is an algorithm used to do asymmetric encryption. This means we have two
distinct keys. Most of the time this means we have one to encrypt plain text to
cipher text, one to decrypt cipher text back to plain text. It is common to have
one of these keys be public and the other be private and secret. Thus, they
might also be called to the public and private key.</p>
<p>RSA uses one simple principle. For encryption with public key \( e \), for
every byte of our plain text \(b_i\) we have encrypted byte \( c_i=b_i^e \)
modulo some integer \( N \). For decryption with private key \( d \), for
every byte of our cipher text \(c_i\) we have encrypted byte \( b_i=c_i^d \)
modulo some integer \( N \). The relationship between these numbers is not as
important for now.</p>
<p>One might wonder how these computations are actually done on the bare hardware.
It turns out that we can interpret this as repeated multiplication and squaring.
This is how that works.</p>
<p>If we are given a number \( x \) and we are tasked with the raising it to the
13th power, we might to it as follows:</p>
<p>\[ x^{13} = x^8 \cdot x^4 \cdot x^1 \]</p>
<p>Noticing the clear ties with powers of 2 here — and thus with binary
—, we might write a custom power function in python as the following.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y)
def custom_pow(x, y):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x

    return res
</code></pre>
<p>If we add a modulo into our function, we have essentially created a function to
do RSA encryption. This is also often how the pseudocode for lower level
implementation looks like.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y) % p
# With p &gt;= 2
def custom_pow_mod(x, y, p):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x
            res %= p # Make sure we stay modulo p

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x
        x %= p # Make sure we stay modulo p

    return res
</code></pre>
<p>If you are already a small bit familiar with Side-Channel Analysis and Power
Analysis, you might immediately see what is going wrong here. If not let us go
through it together.</p>
<p>When we do <em>Power Analysis</em>, we get the power consumption of a computer for a
set time. Let us say we would we have a computer purely executing the
computation for <code>custom_pow_mod(3, 5, 15)</code>. The steps that are taken in this
computation are done noted below. Take a look at that the computation and
verify it in your head.</p>
<pre><code class="language-python">custom_pow_mod(3, 5, 15):

res := 1

# Round 1

# [A]
y &gt; 0 = 5 &gt; 0 is true, thus:
    y &amp; 0x01 = 5 &amp; 0x01 is 1, which equals true, thus:
        # [B]
        res := res * x = 1 * 5 = 5
        res := res % 15 = 5 % 15 = 5

    # [C]
    y := y &gt;&gt; 1 = 5 &gt;&gt; 1 = 2
    x := x * x = 3 * 3 = 9
    x := x % 15 = 9 % 15 = 9


# Round 2

# [D]
y &gt; 0 = 2 &gt; 0 is true, thus:
    y &amp; 0x01 = 2 &amp; 0x01 is 0, which equals false

    # [E]
    y := y &gt;&gt; 1 = 2 &gt;&gt; 1 = 1
    x := x * x = 9 * 9 = 81
    x := x % 15 = 81 % 15 = 6

# Round 3

# [F]
y &gt; 0 = 1 &gt; 0 is true, thus:
    y &amp; 0x01 = 1 &amp; 0x01 is 1, which equals true, thus:
        # [G]
        res := res * x = 5 * 6 = 30
        res := res % 15 = 30 % 15 = 0

    # [H]
    y := y &gt;&gt; 1 = 1 &gt;&gt; 1 = 0
    x := x * x = 6 * 6 = 36
    x := x % 15 = 36 % 15 = 6

# Round 4

# [I]
y &gt; 0 = 0 &gt; 0 is false.

# [J]
Result: 0
</code></pre>
<p>One might notice that every round contains a differing amount of steps, and
thus, we might imagine that the power consumption of our machine looks similar
to <em>Figure 1</em>.</p>
<p><img src="../assets/estimate-power-consumption-rsa.jpg" alt="Estimate of RSA power consumption" /></p>
<p><em>Figure 1: A projected power trace for the</em> <code>custom_pow_mod(3, 5, 15)</code> <em>function call.</em></p>
<blockquote>
<p><strong>NOTE:</strong> This sketch uses the estimate that conditionals and loops (<code>if</code> and
<code>while</code>) are less power consuming than normal numerical calculations (<code>&gt;&gt;</code>,
<code>*</code> and <code>%</code>), which isn't trivially true, but for the sake of
argument we are going to assume it is true.</p>
</blockquote>
<p>You might notice that given this sketch, we can reconstruct some information
about the argument <code>y</code> provided to the <code>custom_pow_mod</code> function. We start with
a long spike, thus, the binary number representation of <code>y</code> starts with a <code>1</code>.
This is followed by a short spike, which indicates a <code>0</code>. And lastly, we see a
long spike again. Therefore, we end with an <code>1</code>. And we get the binary number
<code>101</code> for our <code>y</code>. This equals 5 in decimal, which is correct.</p>
<p>Let us do another one, now without knowing the answer before hand. Take a look
at <em>Figure 2</em>.</p>
<p><img src="../assets/rsa-key-42.jpg" alt="RSA key 42" /></p>
<p><em>Figure 2: A projected power trace for the</em> <code>custom_pow_mod</code> <em>function.</em></p>
<p>We start with two short spikes, and thus we start with two zeros. Then we
alternate a long spike with a short spike three times. This means we get
<code>00101010</code>. This is equal to decimal 42. And thus the <code>y</code> we started with is 42.</p>
<h2 id="what-does-this-tell-us"><a class="header" href="#what-does-this-tell-us">What does this tell us?</a></h2>
<p>The previous code example may seem cherry picked. In fact, it is. It indicates
this concept very nicely and is therefore an extremely good visual example of
how to break a RSA implementation. However, code following the same principle or
even this exact algorithm is extremely common. This means that whilst this exact
method may not be applicable everywhere, the underlying idea still is.</p>
<p>So whilst this method specifically is interesting, we are more interested in
whether looking into an algorithm and deciding if we can tell something about
data used from the patterns in a power trace. In the next chapter, we are going
to have go through how this can be done with AES.</p>
<h1 id="breaking-aes"><a class="header" href="#breaking-aes">Breaking AES</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> or the
<strong>Advanced Encryption Standard</strong>, is one of the most popular symmetric encryption
algorithms in today's world. It is used for most encrypted conversations between
computers or applications. It is used by your chat apps and by your password
manager. AES has the advantage of being relatively fast and easy to understand.</p>
<p>Since AES is very widely used, any found vulnerability should be taken extremely
serious. It is widely considered that AES is mathematically secure and
therefore <em>perfect implementations</em> of the algorithms should not be vulnerable to
most standard attacks. You can see a caveat here:</p>
<p><strong>Have we created perfect implementations of the AES algorithm?</strong></p>
<p>Although there are some AES implementations that have existed for over 2
decades. There are still regular updates to these libraries, because from time to
time people find new mistakes in the implementation of these
algorithms. Code is messy, people make mistakes or are ignorant. Side-channel
analysis is a attack-vector that is often overlooked or ignored since it
requires physical access to the device.</p>
<p>In this section we will have a look at how AES works, a naive implementation of
the algorithm and how power analysis can be used to expose the key used.</p>
<h1 id="how-aes-works"><a class="header" href="#how-aes-works">How AES Works</a></h1>
<p>In order to do break <em>AES</em> with power analysis, we need a reasonably detailed
understanding of how <em>AES</em> works. So let us do a refresher.</p>
<p>The <em>AES</em> algorithm is a subset of the <strong>Rijndael block cipher</strong> algorithm and
has basically become synonymous with it. As the name <strong>Rijndael block cipher</strong>
implies, we apply the encryption to fixed-size blocks of plain text. With the
size of the blocks being equal to the key size. The encryption is based on
alternating <em>XOR</em> operations and shuffling the bytes of the blocks. Let dive
into each individual component.</p>
<h2 id="the-plan"><a class="header" href="#the-plan">The Plan</a></h2>
<p>As said previously, the <em>AES</em> algorithm works by alternating <em>XOR</em> operations
with the shuffling of the bytes of the blocks. The algorithm specifies that this
is done in rounds. Since <em>AES</em> has 3 different key sizes (128, 192 and 256
bits), each different key size also has a different number of rounds. The amount
of rounds are 10, 12, and 14, respectively.</p>
<p>How does a round look like? Although the first round and the last round have
small differences to the rest we can divide all the rounds up into two sections the
shuffling of bytes and the <em>XOR</em> operation. Let us first have a look at the
<em>XOR</em> operations.</p>
<h2 id="xor-operations"><a class="header" href="#xor-operations">XOR operations</a></h2>
<p>The <em>XOR</em> operation is essentially the adding of the key and is what makes the
running of the <em>AES</em> algorithm different depending on what key is used. Firstly,
in order to make reversal even more different, we <strong>create multiple new keys from
the original key</strong>. This is called the
<a href="https://en.wikipedia.org/wiki/AES_key_schedule">AES key schedule</a>. This
walkthrough will not go into detail on how this key-expansion works, but if
interested one can look up details. The part which is import to this walkthrough
is that after this expansion we have as many new keys as we have rounds. We will
number all the from \(k_0\) to \(k_{10}\) (assuming 128 bit <em>AES</em>).
Here \(k_0\) is the original key and \(k_1\) till \(k_{10}\) are
the expanded keys.</p>
<p><img src="aes/../assets/AES_Key_Schedule.svg" alt="AES Key Schedule" /></p>
<p><em>Figure 1: The AES Key Schedule</em></p>
<p>With these keys we performs a <em>XOR</em> on a block. The <em>XOR</em> operation is a
notorious one way operation. This is due to the lack of information the output
shares about the input. When we do a one bit <em>XOR</em> operation and we receive 1 as
an output, the input could have been (0,1) or (1,0). We also have two options
when we get 0 as output. In the case of one bit, this is not that useful.
However, when we a lot of bits the <em>XOR</em> operator is impossible to instantly
reverse for every output and brute forcing time is equal to trying every option
divided by two. Mathematically this caused by the <em>XOR</em> operation being
non-injective. Furthermore, the other argument is incredibly easy to find when
we have one of the arguments. These two properties make it ideal for a lot of
encryption algorithms.</p>
<p><img src="aes/../assets/XOR_NonInjectivity.svg" alt="XOR Non Injective" /></p>
<p><em>Figure 2: The non injective nature of the XOR operation</em></p>
<h2 id="shuffling-of-bytes"><a class="header" href="#shuffling-of-bytes">Shuffling of bytes</a></h2>
<p>Next let us have a look at the other parts of each round. The shuffling of
the block bytes. Rijndael block ciphers have 3 distinct shuffling techniques:
<strong>substitution, shifting, and mixing</strong>. We are going to have a look at all three
of these shuffling techniques, but let us first have a look at how Rijndael
block ciphers view each block.</p>
<h3 id="block-of-blocks"><a class="header" href="#block-of-blocks">Block-of-blocks?</a></h3>
<p>Rijndael looks at blocks as a matrix of bytes. For the key sizes of key sizes of
128, 192 and 256 bits, we have 4 by 4, 6 by 6 and 8 by 8 matrices, respectively.
This would mean that a 128 bit key with bytes \(b_0, ..., b_{15}\) is turned
into \[
\begin{bmatrix}
b_0 &amp; b_4 &amp; b_8 &amp; b_{12} \\
b_1 &amp; b_5 &amp; b_9 &amp; b_{13} \\
b_2 &amp; b_6 &amp; b_{10} &amp; b_{14} \\
b_3 &amp; b_7 &amp; b_{11} &amp; b_{15}
\end{bmatrix}
\]
Turning a long string of bytes into a matrix allows for matrix operations, which
are common operations for computers. This provides both clarity and speed.</p>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<p>Now comes one of the most genius but strange parts of the Rijndael block
cipher. This is the substitution box. A substitution block is basically a lookup
table to replace (or substitute) a byte with the one from the lookup table. Some
demands for such a lookup table (when used in encryption algorithms) may be:</p>
<ul>
<li><strong>Reverseable</strong>: In order to find back the original byte, we want to be able
to reverse the process.</li>
<li><strong>Non-Linear</strong>: In order to make resistant to
<a href="https://en.wikipedia.org/wiki/Linear_cryptanalysis">linear</a> and
<a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis">differential</a>
cryptanalysis, the lookup should be very difficult to approximate with a
linear function.</li>
<li><strong>Fixed Output Sizing</strong>: In order to reduce the complexity and loss of excess
data, we want to output to have a fixed bit size (preferably the same as the
input).</li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-Box</a> does all
these things. Since it has all of these properties, how it specifically looks is
not important. Every implementation of <em>AES</em> can save the Substitution-Box and
its inverse in static memory since it is public knowledge.</p>
<p>Here is the Rijndael S-Box as a python array.</p>
<pre><code class="language-python"># Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]
</code></pre>
<h3 id="shifting"><a class="header" href="#shifting">Shifting</a></h3>
<p>The most plain, but equally important, round step is the shifting of the rows.
This step prevents the columns (4 consecutive bytes in the case of the 128 bit
variant) from being <strong>encrypted and decrypted separately</strong>. The step consists of
shifting the first row of the matrix by zero, the second by one, the third by
two and the fourth by three spaces. This looks as follows:</p>
<p><img src="aes/../assets/Shift_Rows.svg" alt="Shift Rows" /></p>
<p><em>Figure 3: Rijndael block cipher's Shift Row</em></p>
<h3 id="mixing"><a class="header" href="#mixing">Mixing</a></h3>
<p>The last shuffling step mixes the columns in order create <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">cryptographic
diffusion</a>, which makes
it <strong>resistant to statistical analysis attacks</strong>. The step works by multiplying each
column with the following inversable matrix (multiplication meaning modulo
multiplication and addition meaning <em>XOR</em>): \[
\begin{bmatrix}
2 &amp; 3 &amp; 1 &amp; 1 \\
1 &amp; 2 &amp; 3 &amp; 1 \\
1 &amp; 1 &amp; 2 &amp; 3 \\
3 &amp; 1 &amp; 1 &amp; 2
\end{bmatrix}
\]</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Let us now provide a overview for how a typical <em>AES</em> encryption looks. One can
imagine that the decryption is just the inverse of these actions we will
therefore gloss over that part.</p>
<p>As said before, the <em>AES</em> encryption process works in rounds. With every round
needing a separate expanded key. Therefore the first step is to create these key
expansions as described in <a href="aes/workings.html#xor-operations">XOR Operations</a>. Immediately
following this we that the initial round key \(k_0\) and apply the <em>XOR</em> with
it to each block.</p>
<p>After the summation with the initial round key we will start applying rounds (9,
11 and 13 rounds for key sizes 128, 192 and 256 bits, respectively). These
rounds apply the following order attacks: Firstly, we do a <a href="aes/workings.html#substitution">substitution with the
Rijndael S-Box</a>. Secondly, we <a href="aes/workings.html#shifting">shift the rows of the
matrix</a>. Thirdly, we <a href="aes/workings.html#mixing">mix the columns of the matrix up</a>.
Lastly, we <a href="aes/workings.html#xor-operations">add the round key for that round</a>.</p>
<p>If you are counting along, you will notice that the final round is missing. This
is because the final round has a small difference. We <strong>skip the mixing of
columns</strong> step, since it provides nothing in last round.</p>
<p>This all results in the following process:</p>
<ol>
<li><a href="aes/workings.html#xor-operations">Key Expansion</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_0\) by <em>XOR</em></a></li>
<li>Apply 9, 11, or 13 rounds
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#mixing">Mix the columns</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by <em>XOR</em> with \(n\) being the round
number</a></li>
</ol>
</li>
<li>Final round
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by <em>XOR</em> with \(n\) being the round
number</a></li>
</ol>
</li>
</ol>
<p>After reading this one should have a basic overview and understanding of how
<em>AES</em> works, which you will need for your power analysis. If you want a more
visual explanation, you should watch <a href="https://www.youtube.com/watch?v=O4xNJsjtN6E">AES Explained by
Computerphile</a>.</p>
<h1 id="capturing-multiple-traces"><a class="header" href="#capturing-multiple-traces">Capturing multiple traces</a></h1>
<p>AES is a lot more complex than RSA. Although looking at one trace of RSA can
give you a lot of information about the key used, with AES it is a lot more
common to take multiple traces and average them out. Here we are gonna have a
look at how we can upload the <em>AES</em> source code to the chipwhisperer, and then
capture multiple power traces.</p>
<h2 id="base-setup"><a class="header" href="#base-setup">Base setup</a></h2>
<p>Assuming that you have <a href="aes/../preparing.html">setup your environment</a>, we first have
to connect to the scope and the target. The scope being the measuring device and
the target being the microprocessor, which is going to run the encryption
algorithm. In order to connect to the scope and the target, we need the
following code.</p>
<pre><code class="language-python">import chipwhisperer as cw

# Setup a connection with the CW board
# and fetch the scope for using this board.
scope = cw.scope()

# The default settings are fine for now.
scope.default_setup()

# Fetch the target from the scope
# This should be automatically connected
target = cw.target(scope)
</code></pre>
<p>In order to disconnect them again, we can use the following code.</p>
<pre><code class="language-python">scope.dis()
target.dis()
</code></pre>
<h2 id="flashing-the-source-code"><a class="header" href="#flashing-the-source-code">Flashing the source code</a></h2>
<p>Depending on what target we are using, we need different software. We can compile
this ourselves, but most compiled code can also be found online. I suggest
looking at <a href="http://github.com/coastalwhite">this repository TODO INSERT LINK
HERE</a>.</p>
<p>Assuming we are using the Chipwhisperer Lite 32-bit addition, we can the
CWLITEARM hex file. in order to upload the program to the target, we can use
the following python code.</p>
<pre><code class="language-python">from chipwhisperer.capture.api.programmers import STM32FProgrammer
import os

# Initiate a new STM32F Program
# STM32 being the ARM microcontroller that we are using
# https://en.wikipedia.org/wiki/STM32#STM32_F3
program = STM32FProgrammer

# Get the path to the current folder
# Adjust accordingly
aes_firmware_dir = os.path.dirname(os.path.realpath(__file__))
aes_hex_path = os.path.join(aes_firmware_dir, r&quot;hexfiles/simpleserial-aes-CWLITEARM.hex&quot;)

# Apply the program to the actual target
# This allows us to run the hex code on the microcontroller
cw.program_target(scope, program, aes_hex_path)
</code></pre>
<h2 id="capturing-a-trace"><a class="header" href="#capturing-a-trace">Capturing a trace</a></h2>
<p>In order to run our first trace, we need a key and some plain text. The program
we are using is based on <strong>128 bit AES</strong> and therefore we should provide a
128 bit key and a multiple or 128 bits for our plain text. We can quite easily
create our first trace, with the following code.</p>
<pre><code class="language-python"># Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'H4ck3rm4n-l33t42'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the plain text used
# This plain text has to be a multiple of
# 128 bits = 16 bytes = 16 ascii characters in length.
plain_text = bytearray('a' * 16, 'ascii')

# Capture the actual trace
trace = cw.capture_trace(scope, target, plain_text, key)
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Within the SimpleSerial protocol — which is used under the
hood by the ChipWhisperer devices — the <code>capture_trace</code> function
corresponds with a couple of steps (arming the chipwhisperer, sending the
key/plaintext and retrieving the trace data, etc.). This can become important
when implementating your own algorithms. There it may be important to replace
w this one function with its individual steps to get more control over the
commands send. This can be seen in the <em>Python</em> code of the <a href="https://github.com/coastalwhite/simpleserial-c-template">SimpleSerial C
template</a>.</p>
</blockquote>
<p>This is very interesting, but we don't really have any confirmation or
visualization. So let us visualize it with <a href="https://github.com/matplotlib/matplotlib">pyplot</a>.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(trace.wave)
plt.show()
</code></pre>
<p>This should look something like <em>Figure 1</em>.</p>
<p><img src="aes/../assets/aes_single_trace_plot.png" alt="AES Single Power Trace" /></p>
<p><em>Figure 1: AES Single Power Trace</em></p>
<h2 id="capturing-more-than-one-trace"><a class="header" href="#capturing-more-than-one-trace">Capturing more than one trace</a></h2>
<p>We can turn this into multiple traces with a simple <code>for</code> loop. Here we are
going to be using the <a href="https://github.com/tqdm/tqdm">tqdm library</a>, to have a
nice progress bar. So let us create 100 traces with random input text and save
all relevant data into a <a href="https://github.com/numpy/numpy">numpy</a> arrays.
This way we can save the eventual traces and plain texts to a file.</p>
<p>First we define a function for creating random plain text strings.</p>
<pre><code class="language-python">import string
import random

def random_string(length):
    # Define the alphabet of the random string
    # Here we take the lowercase latin alphabet in ascii encoding
    # e.g. &quot;cpjsapcnrsdtjvlo&quot;, &quot;btqfocsprbualtwt&quot; or &quot;yzkwewjbkpmriccx&quot;
    alphabet = string.ascii_lowercase

    # Return a string with the given length with randomly chosen chars
    return ''.join(random.choice(alphabet) for i in range(length))
</code></pre>
<p>Then we capture some traces.</p>
<pre><code class="language-python">from tqdm import trange

# Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'bruteforcing????'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the constant for the amount of traces
N = 5

textins = []
traces = []

# Loop through all traces
for i in trange(N, desc=&quot;Capturing traces&quot;):

    # Define the plain text used
    # This plain text has to be a multiple of
    # 128 bits = 16 bytes = 16 ascii characters in length.
    plain_text = bytearray(random_string(16), 'ascii')

    # Capture the actual trace
    trace = cw.capture_trace(scope, target, plain_text, key)

    # If the capture timed out move to the next capture
    if trace is None:
        continue

    textins.append(plain_text)
    traces.append(trace.wave)
</code></pre>
<p>Then we turn this into numpy arrays.</p>
<pre><code class="language-python">np_traces = np.asarray(traces)
np_textins = np.asarray(textins)
</code></pre>
<p>Then we can save it to a file.</p>
<pre><code class="language-python">np.save('output/traces.npy', np_traces)
np.save('output/textins.npy', np_textins)
</code></pre>
<p>This way we can later load it.</p>
<blockquote>
<p>For more information on how to do scripting with the ChipWhisperer python
module have a look over <a href="https://wiki.newae.com/Making_Scripts">here</a>.
<strong>Disclaimer:</strong> This is quite heavy.</p>
</blockquote>
<h1 id="modeling-aes"><a class="header" href="#modeling-aes">Modeling AES</a></h1>
<p>In order to make sensible statements about the power usage of <em>AES</em>, it can be
handy to make a model of the <em>AES</em> algorithm. To do this, we need some
understanding about how computers use power and how the <em>AES</em> algorithm
functions. The first we will discuss here and the second is discussed in the
chapter <a href="aes/./workings.html">How AES Works</a>.</p>
<h2 id="hamming-distance-and-hamming-weight"><a class="header" href="#hamming-distance-and-hamming-weight">Hamming Distance and Hamming Weight</a></h2>
<p>Remember that computers are just emergent properties that we get when we have a
ton of transitors, capacitors, wires, etc. in the correct setup. This means that
if we look at the capacitors level, there should be some capacitors that
represents the state of a bit. Here mainly the internal state of memory. Since,
we know that capacitors represents a binary 1 with a certain amount of charge
and a binary 0 with (almost) no charge. We can ask ourselves the question, does
it cost more power to set or maintain memory which involves more binary 1's than
0's. In fact, it indeed does. This gives us two models for looking at the power
usage of memory. <strong>Looking at how much power it would take to set memory, which is
known as the Hamming Distance model. Or we can look at how much power it would
take to maintain memory, which is known as the Hamming Weight model.</strong> Hamming
Distance meaning the amount of bitflips needed to turn one memory state into
another, and Hamming Distance meaning the amount of 1's in a certain memory
state.</p>
<p>We can easily create a python function, which would identify the Hamming weight
or Hamming distance.</p>
<pre><code class="language-python"># Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)
</code></pre>
<p>Although it can be worth it to save this to memory, to speed to computation time
later on.</p>
<pre><code class="language-python"># ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]
</code></pre>
<p>Although both models work for power usage, mainly to avoid repetition, from
<strong>here on out we will be using the Hamming Weight model</strong>.</p>
<h2 id="making-a-statement-about-aess-memory-state"><a class="header" href="#making-a-statement-about-aess-memory-state">Making a statement about AES's memory state</a></h2>
<p>Suppose we have an input block \(Input\) and an output block \(Output\),
which is a reasonably common situation. If we would want to check whether a
supposed key is valid, we could run through the entire algorithm to check
whether \(\text{AES}(Input, Key) = Output\). This is quite inefficient and is
no better than brute forcing the key. Knowing what we now about the memory state
of <em>AES</em> we can however do two extreme optimizations.</p>
<h3 id="shortcutting-calculations"><a class="header" href="#shortcutting-calculations">Shortcutting calculations</a></h3>
<p>The first optimization we can do has to do with identifying the first memory state
where the key and the \(Input\) are combined. If we can identify this memory
state in the power trace, we can determine a probability a certain key was used.
There are two problems with this however. Firstly, identifying the presence or
the location of this memory state is non-trivial. It is very difficult to
manually look at a power trace and tell something about memory states. This is
is mostly due to the variances in baseline power consumption but also due to
noise and other factors. Some of these factors however can be nullified if we
look at multiple power traces instead of one. In order to make it even easier,
we also also look at different input blocks. This allows us to shortcut
calculation time by a lot, since we don't have to do multiple rounds. But we
still have to brute force through every key option.</p>
<h3 id="limiting-the-amount-of-keys"><a class="header" href="#limiting-the-amount-of-keys">Limiting the amount of keys</a></h3>
<p>If we have done the first optimization, there is another optimization which
would lower the amount of possible keys. For the 128 (\(2^{128}\) different
keys), 192 (\(2^{192}\) different
keys) and 256 (\(2^{256}\) different
keys) bits key
variants, this leaves just \(2^{12}\), \((3 \cdot 2^{11})\) and \(2^{13}\)
key possibilities left, respectively. These are massive differences, which will
allow us to break <em>AES</em> in just a few seconds.</p>
<p>How does it work? Please read back <a href="aes/./workings.html#shifting">How AES Works -
Shifting</a> for one second and see if you find what we can
exploit, when have a value before this step happens. As it mentions this, step
is needed to prevent <strong>attacking each column individually</strong>. Since we can now
produce a value before this step is done. We can attempt to break parts of the
key one at the time. The parts of this key are called sub-keys and they are 1
byte in size.</p>
<h2 id="putting-this-together"><a class="header" href="#putting-this-together">Putting this together</a></h2>
<p>Let us make a model of the memory states power usage.</p>
<pre><code class="language-python">def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<h1 id="manual-analysis"><a class="header" href="#manual-analysis">Manual Analysis</a></h1>
<p>With the power usage model we described in the previous chapter, we can now
start to do some analysis of our power traces.</p>
<p>Let look what we have up until now.</p>
<pre><code class="language-python"># Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)

# ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<p>In order to load the data we created with our trace we can add the follow few
lines which will load in the numpy arrays.</p>
<pre><code class="language-python">import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

</code></pre>
<h2 id="are-we-data-scientists-yet"><a class="header" href="#are-we-data-scientists-yet">Are we data-scientists yet?</a></h2>
<p>We want to change the data in such a way that it makes it easier to identify
whether a our <strong>modeled power usage is similar to the actual power usage</strong>. We
need multiple power traces for this. The most important of which is the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson
correlation coefficient</a>.</p>
<h3 id="pearson-correlation-coefficient"><a class="header" href="#pearson-correlation-coefficient">Pearson correlation coefficient</a></h3>
<p>We have an difficult task here. Again, we want to know how likely it is that our
modeled power usage has a similar pattern to the actual power usage. In
statistics this is known as the modeled power usage and the actual power usage
having a high <strong>correlation</strong>. If two functions are in perfect correlation,
one function should always rise when the other rises and one function
should always decline when the other declines.</p>
<p>This is what the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation
coefficient</a>
indicates. We provide it with two functions and it will give us a value between
\(-1\) and \(1\), indicating whether the two functions correlate. \(1\)
meaning (unrealistic) levels of correlation, \(0\) meaning no correlation and
\(-1\) meaning a inverse correlation. How the Pearson correlation coefficient
manages to do this is not as important for us, but reading the Wikipedia page
can be very interesting. What is important for us is the formula so we can use
it in our code.</p>
<p>\[
\rho_{X,Y} = \frac{\text{cov}(X,Y)}{\sigma_X \sigma_Y}
\]</p>
<p>This may not be entirely clear to most people without knowledge of
statistics. So let us break it down.</p>
<ul>
<li>\(\rho\) is the letter commonly used to represent the Pearson correlation
coefficient.</li>
<li>\(X\) and \(Y\) are our functions and can actually be represented as a
finite list of numbers in our case. This means \(X = { x_0, \ldots, x_n }\) and
\(Y = { y_0, \ldots, y_n }\) with \(n\) being an integers greater or
equal to zero.</li>
<li>\(\text{cov}(X,Y)\) is the covariance of \(X\) and \(Y\). This can be
calculated with \(\text{cov}(X,Y)=\mathbb{E}[(X - \mu_X)(Y - \mu_Y)] =
\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)(y_i - \mu_Y) \), with
\(\mu_X\) and \(\mu_Y\) being the mean of \(X\) and \(Y\),
respectively.</li>
<li>\(\sigma_X\) and \(\sigma_Y\) being the standard deviation of \(X\) and
\(Y\), respectively. The standard deviation can be calculated with
\(\sigma_X = \sqrt{\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)^2}\) with
\(\mu_X\) being the mean of \(X\).</li>
</ul>
<p>Let us move these formulas to python.</p>
<pre><code class="language-python">def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
</code></pre>
<p>Although this code is very inefficient, and does a lot of unnecessary and double
calculations, it will serve well for now.</p>
<h3 id="cracking-a-single-byte"><a class="header" href="#cracking-a-single-byte">Cracking a single byte</a></h3>
<p>As explained in <a href="aes/./modeling.html">Modeling AES</a>, we can — using power analysis —
<strong>crack the <em>AES</em> key byte by byte</strong>. So let us start with a single one. We are
going to go through every possibility and see which byte one provides the
highest correlation coefficient between the actual power trace and our modeled
power usage. The important realisation here is that we are doing a correlation
between all individual power trace points and the hypothetical power
consumption and we will select the maximum correlation coefficient for all
subkey guesses. This is because we still have no idea where the first round
actually takes place. If we look at all points of each power trace, the location
where the first round takes place should have the highest correlation. We will
demonstrate this later on.</p>
<pre><code class="language-python">from tqdm import trange

def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation

# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
</code></pre>
<p>This will determine the maximum correlation coefficients for all subkey guesses.
If we plot this we get the following graph.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
</code></pre>
<p><img src="aes/../assets/aes_max_correlation_coefficients.png" alt="Maximum Correlation Coefficients AES" /></p>
<p><em>Figure 1: The AES Correlation Coefficients for the first subkey values</em></p>
<p>Remember I used the key <code>H4ck3rm4n-l33t42</code>, where <code>H</code> or ASCII 72 is the first
subkey byte. If you used a different key, your plot will most probably look
different and there will be a high spike at the ASCII value of your first
subkey.</p>
<p>Well done! We have cracked our first subkey!</p>
<h1 id="pearson-correlation"><a class="header" href="#pearson-correlation">Pearson correlation</a></h1>
<p>You might ask yourself, how did it do that? It looks a bit magical with all
these correlations. So let us try to visualize what is actually happening.</p>
<p>We are calculating all the correlation coefficients for all the points within
all traces. So let us compare the result of this calculation between the correct
and a wrong subkey. Again, for me the first subkey is <code>H</code> (ASCII 72 or hex
<code>0x48</code>). If you chose a different key, you should adjust this in the following
code.</p>
<pre><code class="language-python">plt.plot(
    abs(calculate_correlation_coefficients(0x48, 0)),
    label='correct'
)
plt.plot(
    abs(calculate_correlation_coefficients(0x00, 0)),
    label='wrong'
)

plt.legend()
plt.show()
</code></pre>
<p>This will show the following graph.</p>
<p><img src="aes/../assets/aes_correlation_visualization.png" alt="AES Pearson Correlation Explaination" /></p>
<p><em>Figure 1: A visualization of Pearson Correlation Coefficient for AES</em></p>
<p>So what does this graph show? This has the correlation between our modeling
power consumption on the y-axis and the different power traces on the x-axis.
You can see that correlation coefficient remains reasonably consistant for the
wrong subkey. It never goes above \(\sim 0.4\). The correct follows the same
pattern — never really reaching above \(\sim 0.4\) — except for one or two
spikes. At these spikes apparently our model matches the actual power
consumption very closely.</p>
<p>These spikes are what we are interested in. We assume that at the highest of
these spikes the microprocessor was executing the the first round of the <em>AES</em>
algorithm. The memory state based power model we created should match the
pattern of the actual power consumption at that specific point.</p>
<p>Just looking at the results, our assumption was most probably correct.</p>
<h1 id="automatically-cracking-an-entire-key"><a class="header" href="#automatically-cracking-an-entire-key">Automatically cracking an entire key</a></h1>
<p>In this chapter we are going to expand upon the <a href="aes/./manual-analysis.html">Manual
Analysis</a> chapter to make the process automatic and work
on the entire key. Most of what is discussed in this chapter is quite trivial.
If you feel quite comfortable with what was discussed in the previous chapters,
by all means skip this chapter and attempt implement it yourself. If you get
stuck, you can always come here to get a hint.</p>
<h2 id="where-were-we"><a class="header" href="#where-were-we">Where were we?</a></h2>
<p>At the moment we have code for modeling the <em>AES</em> memory based power state,
creating correlation coefficients and a piece to plot the results.</p>
<pre><code class="language-python">import numpy as np
from tqdm import trange

# Modeling the power consumption
########################################
# Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)

# ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
########################################

# Loading our trace data
########################################
import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

########################################

# Pearson correlation
########################################
def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
########################################

# Define a function to calculate the Correlation Coefficients for a byte in a
# subkey.
########################################
def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation
########################################

# Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Plotting the max_correlation_coefficients
########################################
import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
########################################
</code></pre>
<h2 id="automatically-picking-the-best-subkey-guess"><a class="header" href="#automatically-picking-the-best-subkey-guess">Automatically picking the best subkey guess</a></h2>
<p>At the moment we plot the graph of the maximum correlation coefficients and we
determine from there what is the correct option. We can easily automate this
using the observation that the correct option has the highest correlation
coefficient. For this we can use the numpy <code>argmax</code> function.</p>
<p>Replace the code for plotting with the following code.</p>
<pre><code class="language-python"># Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex file and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
</code></pre>
<p>Now the code will automatically print out the option with the highest
correlation coefficient.</p>
<blockquote>
<p><strong>Note:</strong> If we have done only a few traces and our correlation coefficients
are a bit less reliable, we can use <code>np.argsort(...)[::-1]</code> to select multiple
options. With this we can, for example, try to brute force with the top 5.</p>
</blockquote>
<h2 id="cracking-an-entire-key"><a class="header" href="#cracking-an-entire-key">Cracking an entire key</a></h2>
<p>In order for us to crack the entire key, we can just add another <code>for</code> loop.
This loop will go through all subkeys.</p>
<p>This will turn the first following code into the second piece of code.</p>
<pre><code class="language-python"># Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Printing the best guess
########################################
# Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex file and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
########################################
</code></pre>
<pre><code class="language-python"># Looping through all subkeys
########################################
# The eventual key guess
best_guess = np.zeros(16)

# Loop through all possible subkeys
for subkey_index in trange(16, desc=&quot;Subkey Index&quot;):
    # Save all correlation coefficients
    max_correlation_coefficients = np.zeros(256)

    # Loop through values this subkey
    for subkey in range(0x00, 0xff + 1):
        max_correlation_coefficients[subkey] = max(abs(
            calculate_correlation_coefficients(subkey, subkey_index)
        ))
    
    # Save the best guess
    best_guess[subkey_index] = np.argmax(max_correlation_coefficients)
########################################

# Printing the best guess
########################################
print(&quot;Best guess:&quot;)
for b in best_guess: print(&quot;{:02x} &quot;.format(int(b)), end=&quot;&quot;)
print(&quot;&quot;)
for b in best_guess: print(&quot;{}&quot;.format(chr(int(b))), end=&quot;&quot;)
print(&quot;&quot;)
########################################
</code></pre>
<blockquote>
<p><strong>Note:</strong> Our code is not very efficient and thus is might take quite a
bit of time for it to crack entire key.</p>
</blockquote>
<p>This should output the following.</p>
<pre><code class="language-text">Best guess:
48 34 63 6b 33 72 6d 34 6e 2d 6c 33 33 74 34 32
H4ck3rm4n-l33t42
</code></pre>
<h1 id="sidenote-optimizing-our-algorithm"><a class="header" href="#sidenote-optimizing-our-algorithm">Sidenote: Optimizing our algorithm</a></h1>
<p>As you may have noticed our algorithm is now really slow. This is due to the
calculation of Pearson Correlation Coefficients. We can speed this up by a lot
if we notice a couple of things.</p>
<ol>
<li>\(\sqrt{a}\sqrt{b}=\sqrt{a b}\). Since square rooting is a very expensive
operation, we can optimize the calculation of \(\sigma_x \sigma_y\) from
two square root calculations to one.</li>
<li>We are recalculating a lot of averages and standard deviations. We can
precompute these averages and standard deviations and them fetch them instead
of recomputing them.</li>
<li>Since we only care about the maximum correlation coefficient and have no
interest in the value itself, we can stop doing any factorization.</li>
</ol>
<p>In the following code we have created a function which applies these three
optimized functions when calculating the correlation coefficients.</p>
<pre><code class="language-python">point_means = np.mean(traces, axis=0, dtype=np.float64)
point_mean_diff = traces - point_means

point_mean_diff_squared_sum = np.sum(np.power(point_mean_diff, 2), axis=0)

def optimized_calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    hypothetical_power_mean = np.mean(hypothetical_power, dtype=np.float64)
    hypothetical_power_mean_diff = hypothetical_power - hypothetical_power_mean

    hypothetical_power_mean_diff_sum_squared = np.sum(
        np.power(hypothetical_power_mean_diff, 2)
    )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = np.sum(
            hypothetical_power_mean_diff *

            # Look at the individual traces points for every trace
            point_mean_diff[:, point_index]
        ) / np.sqrt(hypothetical_power_mean_diff_sum_squared *
                point_mean_diff_squared_sum[point_index])

    return point_correlation
</code></pre>
<h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<ol>
<li>At the following
<a href="https://github.com/coastalwhite/intro-power-analysis/datasets/aes">location</a>
you can find 3 sets of power traces, can you crack their keys used?</li>
<li>Does the method of statistical analysis apply to the <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha
ciphers</a>. Why does it work? Why does
it not work?</li>
<li>Crack the secret key used for the following ChaCha power trace. The source
code of which can be found <a href="https://githu.com/coastalwhite/cw-chacha">here</a>.
<strong>TODO: HAS TO BE ADDED</strong></li>
</ol>
<h1 id="assignment"><a class="header" href="#assignment">Assignment</a></h1>
<p>As a final assignment for this walkthrough, there should detailed report on some
component of power analysis including a demonstration and what effect it has on
possible attack vectors. A few categories of what we can look at along with some
example topics:</p>
<ul>
<li>Breaking an encryption algorithm which is not discussed in this walkthrough.
Possibly combined with some protections against power analysis. Have a look at
the <a href="./preparing/toolchains.html">Compiling your own algorithms</a> instructions.
Some examples of interesting algorithms are:
<ul>
<li>Breaking the <a href="https://en.wikipedia.org/wiki/Curve25519">Ed25519</a>
algorithm and providing some protections against power analysis. (Have a look
at the <a href="https://github.com/orlp/ed25519">following implementation</a>)</li>
<li>Breaking <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha</a> stream ciphers and
providing some protections against power analysis. (Have a look at the
<a href="https://www.oryx-embedded.com/doc/chacha_8c_source.html">following implementation</a>)</li>
</ul>
</li>
<li>Providing multiple protections on RSA or AES along with analysis of their
effectiveness and remaining attack vectors.</li>
<li>Breaking algorithms by using the data power analysis provides us in new ways.
<ul>
<li>Apply machine learning to the data provides by a power-trace of an
encryption algorithm and determine its effectiveness.</li>
<li>Look further into optimizing the amount traces needed to do a correlation
power analysis attack. How many traces can reliably crack a certain
algorithm? Can this be improved in some way?</li>
</ul>
</li>
</ul>
<p>These are just a few examples within the many possible topics. If another
creative idea pops up, feel free to give it a shot. The only requirements are
within the report are a <strong>reproducible demonstration and explanation of your
method</strong> and a <strong>description of (remaining) attack vectors through power
analysis</strong>.</p>
<h2 id="grading--what-will-be-looked-at"><a class="header" href="#grading--what-will-be-looked-at">Grading / What will be looked at</a></h2>
<p>There are a few important topics to which is going to be payed attention whilst
grading.</p>
<h3 id="complexity-and-creativity-of-method"><a class="header" href="#complexity-and-creativity-of-method">Complexity and creativity of method</a></h3>
<p>Most important is the complexity and creativity of your method. These are best
formulated by the following two questions:</p>
<ol>
<li>What level of difficulty is your attack vector or method of execution?</li>
<li>How much of this method was already predone by other people?</li>
</ol>
<p>This second point also lead to the point that <strong>it is very important to cite
sources for your attacks.</strong> Any found plagarism will <strong>not</strong> be tolerated. If
one uses a piece of text, code or method (almost) directly copied or cited from
a source, cite that (primary) source. If one adapts a piece of text, code or
method from a source, cite as <code>Adapted from ...</code>.</p>
<h3 id="level-of-explanation-and-writing"><a class="header" href="#level-of-explanation-and-writing">Level of explanation and writing</a></h3>
<p>Apart from having a great and creative method, it is also very important to make
clear why and why your method was so great and creative. Go into depth on the
steps of your method and why those reach the desired result. You can assume that
the reader has also followed this walkthrough and albeit has some preliminary
knowledge.</p>
<h3 id="reproducability"><a class="header" href="#reproducability">Reproducability</a></h3>
<p>The final important part of your little research is going to be reproducability.
How easy is it for the people checking your assignment to reproduce your
method(/results). Is your code readable? Is there some clear documentation on
compiling code, executing an attack or installing dependencies? It is not needed
to write step by step instructions yourself for most of these steps, but it is
important to write an overview on installing dependencies (linking to the
installation guide of that dependency), compiling instructions (when needed) and
attack execution instructions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
