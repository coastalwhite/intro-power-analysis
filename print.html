<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Power analysis Introductory Walkthrough</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="preparing.html"><strong aria-hidden="true">2.</strong> Preparing your environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="preparing/python-pip.html"><strong aria-hidden="true">2.1.</strong> Python and PIP</a></li><li class="chapter-item expanded "><a href="preparing/chipwhisperer.html"><strong aria-hidden="true">2.2.</strong> ChipWhisperer</a></li></ol></li><li class="chapter-item expanded "><a href="rsa.html"><strong aria-hidden="true">3.</strong> A case study: RSA</a></li><li class="chapter-item expanded "><a href="aes.html"><strong aria-hidden="true">4.</strong> Breaking AES</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="aes/cpa.html"><strong aria-hidden="true">4.1.</strong> Correlation Power Analysis</a></li><li class="chapter-item expanded "><a href="aes/workings.html"><strong aria-hidden="true">4.2.</strong> How AES works</a></li><li class="chapter-item expanded "><a href="aes/modeling.html"><strong aria-hidden="true">4.3.</strong> Modeling AES</a></li><li class="chapter-item expanded "><a href="aes/capture.html"><strong aria-hidden="true">4.4.</strong> Capture multiple traces</a></li><li class="chapter-item expanded "><a href="aes/key-bytes.html"><strong aria-hidden="true">4.5.</strong> Crack individual key-bytes</a></li><li class="chapter-item expanded "><a href="aes/automate.html"><strong aria-hidden="true">4.6.</strong> Automate the cracking process</a></li><li class="chapter-item expanded "><a href="aes/optimization.html"><strong aria-hidden="true">4.7.</strong> Sidenote: Optimizing our code</a></li><li class="chapter-item expanded "><a href="aes/exercises.html"><strong aria-hidden="true">4.8.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="compiling.html"><strong aria-hidden="true">5.</strong> Compiling/Creating your own algorithms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compiling/toolchains.html"><strong aria-hidden="true">5.1.</strong> Installing Toolchains</a></li><li class="chapter-item expanded "><a href="compiling/simpleserial.html"><strong aria-hidden="true">5.2.</strong> SimpleSerial Protocol</a></li><li class="chapter-item expanded "><a href="compiling/resources.html"><strong aria-hidden="true">5.3.</strong> Existing resources</a></li></ol></li><li class="chapter-item expanded "><a href="assignment.html"><strong aria-hidden="true">6.</strong> Assignment</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Power analysis Introductory Walkthrough</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/coastalwhite/intro-power-analysis" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="power-analysis-introductory-walkthrough"><a class="header" href="#power-analysis-introductory-walkthrough">Power Analysis Introductory Walkthrough</a></h1>
<blockquote>
<p><strong>What will this course cover?</strong></p>
<ul>
<li><a href="./preparing.html">Chapter 2</a> - Installing and configuring capture and
analysis tools</li>
<li><a href="./rsa.html">Chapter 3</a> - Explain <em>Simple Power Analysis</em> by looking at the
RSA algorithm</li>
<li><a href="./aes.html">Chapter 4</a> - Explain <em>Correlation Power Analysis</em> by looking at
the AES algorithm</li>
<li><a href="./compiling.html">Chapter 5</a> - Setting up tools to compile custom algorithms</li>
</ul>
</blockquote>
<p>IT Security has many fields and layers, all of which aim to investigate how to
break and protect the core principles of information security. These principles
are confidentiality, integrity and availability<sup class="footnote-reference"><a href="#tenets">1</a></sup>. One of these fields is
<a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel analysis</a>. Here the focus lies on how technology interacts with the
world around it, and what analysis these interactions can tell us about
calculations or operations done by the technology.</p>
<p>One of the techniques within <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel analysis</a> which aims to break
confidentiality is <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a>. <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> looks at the power
consumption of hardware in order to make statements about the specific
calculations done within a computer. Some calculations require a higher amount
of power than other calculations.</p>
<p>Take a look at the following picture. If we know that the following <em>Figure 1</em>
records a sequence of two different computations - namely, squaring and
taking a product - and we also know that squaring takes marginally less time
than taking a product in this case. You could hypothesize where the power trace
is taking a product and where the trace is squaring a number.</p>
<p><img src="./assets/power_analysis.png" alt="Power Analysis of RSA" /></p>
<p>_Figure 1: Power Trace of a <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> encryption by
<a href="https://en.wikipedia.org/wiki/Power_analysis#/media/File:Power_attack_full.png">Audriusa</a>
(GPFL)</p>
<h2 id="purpose-of-this-walkthrough"><a class="header" href="#purpose-of-this-walkthrough">Purpose of this walkthrough</a></h2>
<p>This walkthrough is meant to be an introduction into both power analysis and
using the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework.  It expects you to have some basic
knowledge of <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> and probably <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a>.  It also helps to be comfortable with a
terminal and the shell. This walkthrough is not about programming or the shell,
however, and most of what is discussed could be followed along with, even if you
have very little programming experience. There is, however, a lot of pseudocode.</p>
<p>Furthermore, if you plan on doing your own traces, you will need a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board. This walkthrough will provide predefined data
sets, so you can do some analysis without doing the traces yourself. This
could save you from buying a <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board. It is, however,
highly recommended doing traces yourself. If you are looking at buying a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board and don't know what to use, this walkthrough is
created using on the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite ARM</a> variant. It is a relatively cheap all-in-one
solution.</p>
<h2 id="chipwhisperer"><a class="header" href="#chipwhisperer">ChipWhisperer</a></h2>
<p>Normally, to make these power measurements on microprocessors, you need a lot of
expensive equipment.  Equipment such as multimeters, oscilloscopes, different
microcontrollers, connectors, etc. This is where the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> comes in.
The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework provides microcontrollers to test and run you
algorithms on, which are referred to as <em>targets</em>. But also provides
measurement devices, which when put together with a target is referred to as a
<em>scope</em>. <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> goes further than a playground and can be used in
real world environments, which makes an ideal framework to learn power analysis
with. Partially because scopes can also be connected to other unrelated
microprocessors in order to do power measurements on those.</p>
<h2 id="errors-and-contributing"><a class="header" href="#errors-and-contributing">Errors and contributing</a></h2>
<p>This walkthrough along with all the content made for it can be found on
<a href="https://github.com/coastalwhite/intro-power-analysis">GitHub</a>. If you find any
errors or feel like something is unclear/left untouched, don't hesitate to
create an issue or pull-request on the page there.</p>
<div class="footnote-definition" id="tenets"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.lbmc.com/blog/three-tenets-of-information-security/">Three Tenets of Information Security by Mark
Burnette</a></p>
</div>
<h1 id="preparing-your-environment"><a class="header" href="#preparing-your-environment">Preparing your environment</a></h1>
<blockquote>
<p><strong>What will this chapter cover?</strong></p>
<ul>
<li>How to install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> and [PIP]</li>
<li>How to install dependencies for the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Python library</li>
<li>How to install the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Python library</li>
</ul>
</blockquote>
<p>This chapter expects the reader to have a personal computer
(running a modern version of <em>Windows</em>, <em>macOS</em> or a commonly used <em>GNU/Linux</em>
distribution) to which one has root/administrator permissions. Furthermore,
especially for <em>macOS</em> and <em>GNU/Linux</em>, a basic understanding of the shell is
recommended.</p>
<p>Although working with the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> requires little setup, it has some
prerequisites. Apart from the usual text editor and <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, we need to install
some libraries and toolchains. What we need to install also depends on what we
want to achieve with this walkthrough. So the next few sections are going to
take you through some common necessities. Along with some of the things that
could come in handy whilst following this walkthrough.</p>
<h1 id="python-and-pip"><a class="header" href="#python-and-pip">Python and PIP</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Installing <a href="preparing/python-pip.html#installing-python">Python</a></li>
<li>Installing <a href="preparing/python-pip.html#installing-pip">PIP</a></li>
<li>Installing mandatory dependencies: <a href="preparing/python-pip.html#numpy">NumPy</a></li>
<li>Installing optional dependencies: <a href="preparing/python-pip.html#pyplot">PyPlot</a> &amp; <a href="preparing/python-pip.html#tqdm">TQDM</a></li>
</ul>
</blockquote>
<p>We are going to be heavily relying on <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> to do most of our measurements.
We are also going to do some data analysis using <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>. Because of this heavy
reliance on <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, we need to install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> along with some packages for it.
Two will be mandatory: <a href="https://numpy.org/">NumPy</a> and the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> library (which will be
covered in <a href="preparing/./chipwhisperer.html">ChipWhisperer</a>) and two are optional but very
useful: <a href="https://matplotlib.org/">matplotlib</a> which is used for data plotting and <a href="https://github.com/tqdm/tqdm">TQDM</a> which is used
for visual feedback whilst cracking.</p>
<h2 id="installing-python"><a class="header" href="#installing-python">Installing Python</a></h2>
<p>The code provided by this walkthrough uses <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 3 and will <strong>NOT</strong> work on
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 2. Installing <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is a platform dependent workflow. Here are some
common operating systems, for other operating systems a simple <a href="https://letmegooglethat.com/?q=installing+python">Google
search</a> or a glance at
<a href="https://www.python.org/">Python.org</a> should do the trick.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>For <em>Windows</em>, download and run the <em>Windows installer</em> from
<a href="https://www.python.org/downloads/windows/">Python.org</a>. For most people the
64-bit version should be the one.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>For <em>macOS</em>, you can either install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> using <a href="https://brew.sh/">Homebrew</a>
with the following shell command.</p>
<pre><code class="language-bash">brew install python3
</code></pre>
<p>Or you can install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> via the <a href="https://www.python.org/downloads/mac-osx/">macOS
Installer</a>. Depending on whether you
own an Intel-based macOS device or an ARM-based macOS, you can select the 64-bit
Intel or 64-bit universal2 installer, respectively.</p>
<blockquote>
<p><em>Note:</em> <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> on <em>macOS</em> tends to give a lot of problems. There is a big
chance that <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is already installed or that only <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 2 is
installed.</p>
</blockquote>
<h3 id="gnulinux"><a class="header" href="#gnulinux">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, you can use the following commands.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install python3 python3-pip
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, you can use the following
command.</p>
<pre><code class="language-bash">sudo pacman -S python python-pip
</code></pre>
<h3 id="validating-your-installation"><a class="header" href="#validating-your-installation">Validating your installation</a></h3>
<p>To check whether your installation was successful, restart your shell and run
the following command.</p>
<pre><code class="language-bash">python3 --version
</code></pre>
<p>For most installations, this should have also installed <code>pip</code>. We can verify
this with.</p>
<pre><code class="language-bash">pip3 help
</code></pre>
<blockquote>
<p><em>Note:</em> If <a href="https://pypi.org/project/pip/">pip</a> is not installing by default when you install Python. A
simple google search should do the trick.</p>
</blockquote>
<h2 id="numpy"><a class="header" href="#numpy">NumPy</a></h2>
<p>One of the most common packages used in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is the <a href="https://numpy.org/">NumPy</a> package. We are
also going to be using it here to do some data transformations. To install
<a href="https://numpy.org/">NumPy</a> we can use <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">pip install numpy
</code></pre>
<h2 id="pyplot"><a class="header" href="#pyplot">PyPlot</a></h2>
<p>With our data it may be handy to plot our data. Most of the plotting done in
this walkthrough has the image attached with it, however. <a href="https://matplotlib.org/">Matplotlib</a> is
therefore recommended, but optional.  Installing is also via <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">python -m pip install -U matplotlib
</code></pre>
<h2 id="tqdm"><a class="header" href="#tqdm">TQDM</a></h2>
<p>To have a better overview of the progress our calculations are making, this
walkthrough uses the progress bars from <a href="https://github.com/tqdm/tqdm">TQDM</a>.
This is also optional, but indeed very handy. Installation can be done via <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">pip install tqdm
</code></pre>
<h2 id="verifying-installation-of-packages"><a class="header" href="#verifying-installation-of-packages">Verifying installation of packages</a></h2>
<p>Go into the <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> interpreter by running <code>python3</code> in your shell. We can
verify the installation of all the packages by running the following few
commands:</p>
<pre><code class="language-python">import numpy
import matplotlib
import tqdm
</code></pre>
<p>If none of those three returned an error, everything is installed correctly!</p>
<p>We have now installed <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, <a href="https://pypi.org/project/pip/">PIP</a> and some packages used throughout this
walkthrough. We have also verified that everything is properly installed.</p>
<h1 id="chipwhisperer-1"><a class="header" href="#chipwhisperer-1">ChipWhisperer</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Installing the ChipWhisperer Python Library for different Operating Systems
<ul>
<li><a href="preparing/chipwhisperer.html#windows">Windows</a></li>
<li><a href="preparing/chipwhisperer.html#macos">macOS</a></li>
<li><a href="preparing/chipwhisperer.html#gnulinux">GNU/Linux</a></li>
</ul>
</li>
<li><a href="preparing/chipwhisperer.html#verifying-installation">Verifying that the installation was successful</a></li>
</ul>
</blockquote>
<p>The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework has a <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> library to interact with its
devices.  This library is definitely a necessity if you plan on doing your own
traces.</p>
<h2 id="installing-the-dependencies"><a class="header" href="#installing-the-dependencies">Installing the dependencies</a></h2>
<p>The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python library has some dependencies. Mainly, these
dependencies are <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> and <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>. Let us go over the different operating
systems and what needs to be done there.</p>
<blockquote>
<p><em>Note:</em> If something here is not working correctly or not up to date. Refer
back to the original <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> documentation that can be found
<a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html">here</a>.</p>
</blockquote>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>For <em>Windows</em>, we mainly need to install <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>. There are multiple ways to do
this. I suggest installing <a href="https://letmegooglethat.com/?q=MinGW">MinGW</a> and
adding <code>MinGW\msys\1.0\bin</code> to your <code>PATH</code> environment variable.</p>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p>For <em>macOS</em>, <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a> should already be installed. To install <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a>, we can
use <a href="https://brew.sh/">Homebrew</a>.</p>
<pre><code class="language-bash">brew install libusb
</code></pre>
<h3 id="gnulinux-1"><a class="header" href="#gnulinux-1">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, we can install both <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a> and
<a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> using the following command.</p>
<pre><code class="language-bash">sudo apt install libusb-dev make
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, we can install both <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>
and <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> using the following command.</p>
<pre><code class="language-bash">sudo pacman -S libusb make
</code></pre>
<h2 id="installing-the-python-library"><a class="header" href="#installing-the-python-library">Installing the python library</a></h2>
<p>To install the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> library, we can use <a href="https://pypi.org/project/pip/">pip</a>. We install it with the following
command.</p>
<pre><code class="language-bash">pip install chipwhisperer
</code></pre>
<h2 id="linux-udev-rules"><a class="header" href="#linux-udev-rules">Linux udev rules</a></h2>
<p>When we are going to start doing traces, one might run into a <em>missing
permissions</em> error on Linux. This has to do with the <code>udev</code> rules. How to solve
this, refer to the <a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#hardware-drivers">ChipWhisperer
docs</a>.
This should solve having to run everything with <code>sudo</code>, which is not preferred.</p>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying installation</a></h2>
<p>To verify that the installation succeeded, we can start <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> in interactive
mode using the <code>python3</code> shell command. Then we should see something such as the
following.</p>
<pre><code class="language-text">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>We can use the following <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code to attempt to import the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>
python library.</p>
<pre><code class="language-python3">import chipwhisperer
</code></pre>
<p>If there aren't any error messages, we have successfully installed the
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python library!</p>
<p>We have now correctly installed everything necessary to perform our own power
measurements using <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> boards. Furthermore, we have also verified
our installation.</p>
<h1 id="a-case-study-rsa"><a class="header" href="#a-case-study-rsa">A case study: RSA</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>What is <em>Simple Power Analysis</em>?</li>
<li>What is the <em>RSA</em> algorithm?</li>
<li>How can you break implementations of <em>RSA</em> using <em>Simple Power Analysis</em>?</li>
</ul>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is an encryption algorithm that is used all over the place. That little
padlock in your browser; it is powered by <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>. Coding an implementation of
<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is reasonably simple, but the mathematics behind it can prove to be really
though. Luckily, there is no need to dive too much into the mathematics to crack
<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> using <a href="https://en.wikipedia.org/wiki/Power_analysis#Simple_power_analysis">Simple Power analysis</a>. In the chapter on <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, we will go a bit
deeper into cache-based <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> attacks, why they work exactly and how
to perform them on the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>. This chapter is going to skip over a few
of the specifics to create a better overview of our method and goals.</p>
<h2 id="what-is-simple-power-analysis"><a class="header" href="#what-is-simple-power-analysis">What is Simple Power Analysis</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Power_analysis#Simple_power_analysis">Simple Power Analysis</a> (also known as SPA) is a way of leaking information from
power measurements of a microprocessor. One can imagine that a microprocessor in
idle will use less power than a microprocessor running instructions at maximum
speed. Similarly, some processor instructions use more power than others or use
power at different intervals. If we take a series of power measurements of a
microprocessor performing an algorithm, we use therefore possible say something
about the instructions that processors performed. The technique of looking at
such power measurements and leaking information from them is called <a href="https://en.wikipedia.org/wiki/Power_analysis#Simple_power_analysis">Simple
Power Analysis</a>.</p>
<p>We are going to exploit this technique with an encryption algorithm called
<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>. In some software implementations of <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>, we can leak secret information
just by looking at power measurements of the microprocessor.</p>
<h2 id="what-is-rsa"><a class="header" href="#what-is-rsa">What is RSA?</a></h2>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is an algorithm used to do <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">asymmetric
encryption</a>. This means
we have two distinct keys. Most of the time this means we have one key to
encrypt plain text to cipher text, one key to decrypt cipher text back to plain
text. It is common to have one of these keys be publicly available while the
other is kept extremely private. Because of this, it is also called the public
and private key cryptography.</p>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> uses one simple principle. For encryption with public key \( e \), for
every byte of our plain text \(b_i\) we have encrypted byte \( c_i=b_i^e \)
modulo some integer \( N \). For decryption with private key \( d \), for
every byte of our cipher text \(c_i\) we have encrypted byte \( b_i=c_i^d \)
modulo some integer \( N \). The specific relationship between these numbers is not as
important for now.</p>
<p>When one learns that usually the minimum key length for the private key is <em>1024
bits</em>, one might wonder how these computations are actually done on the bare
hardware. It turns out that we can interpret modulo exponentiation as
repeated multiplication and squaring alternated with modulo division. This is
how that works.</p>
<p>If we are given an enormous number \( x \), and we are tasked with the raising
it to the 13th power, we might do it as follows:</p>
<p>\[ x^{13} = x^8 \cdot x^4 \cdot x^1 \]</p>
<p>This is part of the method of <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">Modular
Exponentiation</a>. Notice
that \((13)_{10} = (1101)_2\). There are some ties with powers of 2 here.
Thus, we might write a custom power function in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> as the following.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y)
def custom_pow(x, y):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x

    return res
</code></pre>
<p>If we add a modulo into our function, we have essentially created a function to
do RSA encryption. This is also often how the pseudocode for lower level
implementation looks like.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y) % p
# With p &gt;= 2
def custom_pow_mod(x, y, p):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x
            res %= p # Make sure we stay modulo p

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x
        x %= p # Make sure we stay modulo p

    return res
</code></pre>
<blockquote>
<p><strong>Note:</strong> This is in fact also how most arbitrary precision library implement
raising to the power. This is due to the (relatively) low maximum complexity of
this calculation.</p>
</blockquote>
<p>If you are already a small bit familiar with <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel Analysis</a> and <a href="https://en.wikipedia.org/wiki/Power_analysis">Power
Analysis</a>, you might immediately see what is going wrong here. If you don't see
it immediately, let us go through it together.</p>
<p>When we do <a href="https://en.wikipedia.org/wiki/Power_analysis">Power Analysis</a>, we get the power consumption of a microprocessor
for a given amount of time. Let us say we would have a computer which purely
executing the computation for <code>custom_pow_mod(3, 5, 15)</code>. The steps that are
taken in this computation are done noted below. Take a look at that the
computation and verify it in your head.</p>
<pre><code class="language-python">custom_pow_mod(3, 5, 15):

res := 1

# Round 1

# [A]
y &gt; 0 = 5 &gt; 0 is true, thus:
    y &amp; 0x01 = 5 &amp; 0x01 is 1, which equals true, thus:
        # [B]
        res := res * x = 1 * 5 = 5
        res := res % 15 = 5 % 15 = 5

    # [C]
    y := y &gt;&gt; 1 = 5 &gt;&gt; 1 = 2
    x := x * x = 3 * 3 = 9
    x := x % 15 = 9 % 15 = 9


# Round 2

# [D]
y &gt; 0 = 2 &gt; 0 is true, thus:
    y &amp; 0x01 = 2 &amp; 0x01 is 0, which equals false

    # [E]
    y := y &gt;&gt; 1 = 2 &gt;&gt; 1 = 1
    x := x * x = 9 * 9 = 81
    x := x % 15 = 81 % 15 = 6

# Round 3

# [F]
y &gt; 0 = 1 &gt; 0 is true, thus:
    y &amp; 0x01 = 1 &amp; 0x01 is 1, which equals true, thus:
        # [G]
        res := res * x = 5 * 6 = 30
        res := res % 15 = 30 % 15 = 0

    # [H]
    y := y &gt;&gt; 1 = 1 &gt;&gt; 1 = 0
    x := x * x = 6 * 6 = 36
    x := x % 15 = 36 % 15 = 6

# Round 4

# [I]
y &gt; 0 = 0 &gt; 0 is false.

# [J]
Result: 0
</code></pre>
<p>One might notice that not every round contains the same amount of steps, and
thus, we might imagine that the power consumption of our machine looks similar
to <em>Figure 1</em>.</p>
<p><img src="./assets/estimate-power-consumption-rsa.jpg" alt="Estimate of RSA power consumption" /></p>
<p><em>Figure 1: A projected power trace for the</em> <code>custom_pow_mod(3, 5, 15)</code> <em>function
call.</em></p>
<blockquote>
<p><em>Note:</em> This sketch uses the estimate that conditionals and loops (<code>if</code> and
<code>while</code>) are less power consuming than normal numerical calculations (<code>&gt;&gt;</code>,
<code>*</code> and <code>%</code>), which isn't trivially true, but for the sake of
simplicity we are going to assume it is true.</p>
</blockquote>
<p>You might notice that given this sketch, we can reconstruct some information
about the argument <code>y</code> provided to the <code>custom_pow_mod</code> function. We start with
a long spike, thus, the binary number representation of <code>y</code> starts with a <code>1</code>.
This is followed by a short spike, which indicates a <code>0</code>. And lastly, we see a
long spike again. Therefore, we end with an <code>1</code>. And we get the binary number
<code>101</code> for our <code>y</code>. This equals 5 in decimal, which is correct.</p>
<p>Let us do another one, now without knowing the answer beforehand. Take a look
at <em>Figure 2</em>.</p>
<p><img src="./assets/rsa-key-42.jpg" alt="RSA key 42" /></p>
<p><em>Figure 2: A projected power trace for the</em> <code>custom_pow_mod</code> <em>function.</em></p>
<p>We start with two short spikes, and thus we start with two zeros. Then we
alternate a long spike with a short spike three times. This means we get
<code>00101010</code>. This is equal to decimal 42. And thus the <code>y</code> we started with is 42.</p>
<h2 id="what-does-this-tell-us"><a class="header" href="#what-does-this-tell-us">What does this tell us?</a></h2>
<p>The previous code example may seem cherry-picked. In fact, it is not. This code
snippet does, however, indicate the concept of <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> very nicely and
is therefore a fantastic visual example of how to break an <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>
implementation. Code following the same principle or even this exact algorithm
is extremely common. This means that whilst this exact method may not be
applicable everywhere, the underlying idea still is.</p>
<p>So whilst this method specifically is interesting, we are more interested in
whether looking into an algorithm can tell us something about data used from the
patterns in a power trace. In the next chapter, we are going through how this
can be done with <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>.</p>
<h1 id="breaking-aes"><a class="header" href="#breaking-aes">Breaking AES</a></h1>
<blockquote>
<p><strong>What will this chapter cover?</strong></p>
<ul>
<li>Describe what <a href="./aes/cpa.html">Correlation Power Analysis</a> is</li>
<li>Explain in full detail <a href="./aes/workings.html">how AES works</a></li>
<li>Explain <a href="./aes/modeling.html">creating a leakage model for AES</a> in full
detail</li>
<li>Cover <a href="./aes/capture.html">how to capture multiple traces</a> with the
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework</li>
<li>Explain <a href="./aes/key-bytes.html">how to crack individual key-bytes</a> from power
traces</li>
<li>Describe in which way we can <a href="./aes/automate.html">automate the cracking
process and crack whole keys</a></li>
</ul>
</blockquote>
<p><a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> or the <em>Advanced Encryption Standard</em>, is one of the most used
symmetric encryption algorithms in today's world. It is used for most encrypted
conversations between computers or applications. It is used by your chat apps
and by your password manager. <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> has the advantage of being relatively fast and
easy to understand.</p>
<p>Since <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> is very widely used, any found vulnerability should be taken extremely
serious. It is widely considered that <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> is mathematically secure and
therefore <em>perfect implementations</em> of the algorithms should not be vulnerable to
most standard attacks. You may see a caveat here:</p>
<p><strong>Have we created perfect implementations of the AES algorithm?</strong></p>
<p>Although there are some <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> implementations that have existed for over 2
decades<sup class="footnote-reference"><a href="#openssl">1</a></sup>. There are still regular updates to these libraries, because
from time to time people find new mistakes in the implementation of these
algorithms. Code is messy, people make mistakes or are ignorant. <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel
analysis</a> is an attack-vector that is often overlooked or ignored since it
requires physical access to the device.</p>
<p>In this section we will have a look at how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works, cracking a naive
implementation of the algorithm and see how <a href="https://en.wikipedia.org/wiki/Power_analysis">Power Analysis</a> can be used to
expose the key used.</p>
<div class="footnote-definition" id="openssl"><sup class="footnote-definition-label">1</sup>
<p>OpenSSL has been copyrighted since 1999 — <a href="https://www.openssl.org/">https://www.openssl.org/</a></p>
</div>
<h1 id="correlation-power-analysis"><a class="header" href="#correlation-power-analysis">Correlation Power Analysis</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Seeing electronics as capacitors</li>
<li>Hamming Weight and Hamming Distance models</li>
<li>Correlation coefficients</li>
</ul>
</blockquote>
<p>Not all algorithms perform different processor-instructions based on what
(private) key was used. Most <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">symmetric encryption</a> algorithms use some form of
byte shuffles and substitution boxes, which have the same amount of
processor-instructions for every possible key. Still however, there is a way to
crack the keys used by these algorithms using power analysis. The method does
not depend on differing instructions, however. Instead, this method focuses on
the power used by the memory and registers.</p>
<h2 id="leakage-models"><a class="header" href="#leakage-models">Leakage Models</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> depends on leakage models. These are models which predict how
much power is going to be used depending on some task a
microprocessor-controlled device performs. In the case of <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> this leakage
model was based on the processor instructions. There are other leakage models,
however. <a href="https://wiki.newae.com/Correlation_Power_Analysis">Correlation Power Analysis</a> is a technique which (most of the time) is
memory-based. Within this technique, we try to find out whether there is a
connection between our leakage model — and its hypothetical key —
and the actual power consumption. Such a connection is also known as a
statistical <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>.  Memory-based leakage models often choose between two
different techniques: <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> and <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a>. In short:
<em>Looking at how much power it would take to set memory is known as the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming
Distance</a> model. Looking at how much power it would take to maintain memory,
which is known as the <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> model.</em></p>
<h3 id="hamming-weight"><a class="header" href="#hamming-weight">Hamming Weight</a></h3>
<p>The <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> model states that there should be a <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between
the amount of bits in the <em>on</em> or \(1\) state and the amount of power a device
uses. This idea stems from the fact that bits in <a href="https://en.wikipedia.org/wiki/Random-access_me,mory">RAM</a> are physical capacitors,
which need to be refreshed often. This process of refreshing the state of <a href="https://en.wikipedia.org/wiki/Random-access_me,mory">RAM</a>
costs an amount of power which is proportional to the amount of bits in the <em>on</em>
or \(1\) state.</p>
<p>For example, the bit-string \(s=010010101\) has \(4\) bits in the in <em>on</em>
state and thus the <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> of \(s\) is \(4\). A general
mathematical expression for the <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> of a bit-string \(s\) is \[
\text{HammingWeight} ( s ) = \# \{s_i \in s : s_i = 1\} \]</p>
<h3 id="hamming-distance"><a class="header" href="#hamming-distance">Hamming Distance</a></h3>
<p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> model states that there should be a <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between
the amount of bits switching between the <em>on</em> (\(1\)) and the <em>off</em> (\(0\))
state and the amount of power a device uses. Register bits are often set to a
specific voltage before reassignment. This is for power efficiency reasons.
Because of this the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> model works better on hardware
implementations of encryption algorithms.</p>
<p>For example, switching from the bit-string \(p=010010101\) to
\(c=110011001\) yields a <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> of \(3\), because \(3\) bits
were flipped. A general mathematical expression for the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> from a
bit-string \(p\) to a bit-string \(c\) with \(|p| = |c|\) is
\[ \text{HammingDistance} ( p, c ) = \# \{ i : p_i \not= c_i \text{ with }
i \in \{1,...,|p|\} \} \]</p>
<h3 id="memory-based-models"><a class="header" href="#memory-based-models">Memory-based models</a></h3>
<p>Now that we have seen two different models for <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between
memory-usage and power consumption, we might ask ourselves how we go from these
concepts to a functional model for an encryption algorithm. We have to
determine a memory state which we can test for. Trivially, this memory state
should be dependent on the (private) key used. Next to that, we have two
preferences for this memory state:</p>
<ol>
<li>Ideally, the memory state is dependent on the input string. This allows us to
look for different memory values. Instead of just searching for the same
derivative of the key memory value.</li>
<li>Preferably, the <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a>/<a href="https://en.wikipedia.org/wiki/Hamming_distance">Distance</a> value holds for
a longer time. With <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a>, for example, a memory state just before
shifting bytes around works better, because transpositions don't affect the
<a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a>.</li>
</ol>
<h2 id="correlations"><a class="header" href="#correlations">Correlations</a></h2>
<p>In order to determine whether there is a connection between a leakage model and
the power consumption, we are going to be determining whether there is a
<a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between that leakage model and the power trace at every point in
time. This means we are going to need multiple <em>power traces</em>: multiple power
consumption values for each point in time. This assumes we have already
(roughly) <a href="https://en.wikipedia.org/wiki/Sum_of_absolute_differences">synchronized</a> our power traces. On the
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>, this done on the instruction level with our compiled
algorithms, so we don't have to worry about it too much.</p>
<h3 id="pearson-correlation-coefficients"><a class="header" href="#pearson-correlation-coefficients">Pearson Correlation Coefficients</a></h3>
<p>Now, however, we are also tasked with determining how well our set of power
traces correlates with our leakage model. Just to summarize, we want to know how
likely it is that our modeled power usage has a similar pattern to the actual
power usage.  In statistics this is known as the modeled power usage and the
actual power usage having a high <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>. If two functions are in perfect
correlation, both functions rise and fall at the same time.</p>
<p>This is what the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation coefficient</a> indicates. We provide it with
two functions or arrays, and it will give us a value between \(-1\) and
\(1\), indicating whether the two functions <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlate</a>. \(1\) meaning
extreme but almost unrealistic levels of <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>, \(0\) meaning no
<a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> and \(-1\) meaning an inverse <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>. How the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson
correlation coefficient</a> manages to do this is not as important for us, but
reading the Wikipedia page can be very interesting. What is important for us
now, is the formula so we can use it in our code.</p>
<p>\[
\rho_{X,Y} = \frac{\text{cov}(X,Y)}{\sigma_X \sigma_Y}
\]</p>
<p>This may not be entirely clear to most people without knowledge of
statistics. So let us break it down.</p>
<ul>
<li>\(\rho\) is the letter commonly used to represent the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation
coefficient</a>.</li>
<li>\(X\) and \(Y\) are our functions and can actually be represented as a
finite list of numbers in our case. This means \(X = \{ x_0, \ldots, x_n
\}\) and \(Y = \{ y_0, \ldots, y_n \}\) with \(n\) being an integer
greater than zero.</li>
<li>\(\text{cov}(X,Y)\) is the <a href="https://en.wikipedia.org/wiki/Covariance">covariance</a> of \(X\) and \(Y\). This can be
calculated with \(\text{cov}(X,Y)=\mathbb{E}[(X - \mu_X)(Y - \mu_Y)] =
\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)(y_i - \mu_Y) \), with
\(\mu_X\) and \(\mu_Y\) being the <a href="https://en.wikipedia.org/wiki/Mean">mean</a> of \(X\) and \(Y\),
respectively.</li>
<li>\(\sigma_X\) and \(\sigma_Y\) being the <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of \(X\) and
\(Y\), respectively. The <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> can be calculated with
\(\sigma_X = \sqrt{\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)^2}\) with
\(\mu_X\) being the <a href="https://en.wikipedia.org/wiki/Mean">mean</a> of \(X\).</li>
</ul>
<p>So let us try to visualize what is actually going to be happening.</p>
<p>We are calculating all the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficients</a>
between the power traces and our leakage model for all the points in time. Then
we choose the highest <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>. At that point in time our
hypothetical memory state should have occurred. When we repeat this with all
keys in our leakage model, the correct key should correlate most at some point
in the power trace.</p>
<p>For example, if we take 100 power traces and correlate each point of time with a
memory-based leakage model. Once using the correct key, and another time using a
wrong key. It might look something like the following graph. On the vertical
axis is the <a href="https://en.wikipedia.org/wiki/Absolute_value">absolute</a> of the correlation and on the horizontal axis we see time
represented by \(5000\) power measurements.</p>
<p><img src="aes/../assets/aes_correlation_visualization.png" alt="AES Pearson Correlation Explanation" /></p>
<p><em>Figure 1: A visualization of <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson Correlation Coefficient</a> for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></em></p>
<p>So what does this graph show? You can see that the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a> remains reasonably consistent for the wrong key.  It
never goes above \(\sim 0.4\). The graph of the correct key follows the same
pattern — never really reaching above \(\sim 0.4\) — except for one or two
spikes. At these spikes apparently our model matches the actual power
consumption very closely. These spikes are what we are interested in.</p>
<h2 id="so-what-did-we-learn"><a class="header" href="#so-what-did-we-learn">So what did we learn?</a></h2>
<p>Determining what key was used is not only possible using leakage models based on
differing processor instructions. We can also correlate memory-based leakage
models, using the Hamming Weight or Hamming Distance hypotheses, with multiple
power traces to determine how likely it is that a certain memory state occurred
during a power trace.</p>
<h1 id="how-aes-works"><a class="header" href="#how-aes-works">How AES Works</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>The inner workings of the AES algorithm.</li>
<li>Different operations utilized by Rijndael block ciphers:
<ul>
<li><a href="aes/workings.html#xor-operations">XOR operations</a></li>
<li><a href="aes/workings.html#substitution">Byte subtitutions and S-Boxes</a></li>
<li><a href="aes/workings.html#shifting">Shifting of Rows</a></li>
<li><a href="aes/workings.html#shifting">Mixing of Rows</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>In order to do break <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> with power analysis, we need a reasonably detailed
understanding of how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works. So let us do a crash course.</p>
<p>The <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm is a subset of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a> algorithm and
has basically become synonymous with it. As the name <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>
implies, we apply the encryption to fixed-size blocks of plain text. With the
size of the blocks being equal to the key size. The encryption is based on
alternating <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations and shuffling the bytes of the blocks. Let dive
into each individual component of the algorithm.</p>
<h2 id="the-plan"><a class="header" href="#the-plan">The Plan</a></h2>
<p>As said previously, the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm works by alternating <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations
with the shuffling of the bytes of the blocks. The algorithm specifies that this
is done in rounds. Since <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> has 3 different key sizes (128, 192 and 256
bits), each different key size also has a different number of rounds. The amount
of rounds are 10, 12, and 14, respectively.</p>
<p>How does a round look like? Although the first round and the last round have
small differences to the rest we can divide all the rounds up into two sections the
shuffling of bytes and the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation. Let us first have a look at the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations.</p>
<h2 id="xor-operations"><a class="header" href="#xor-operations">XOR operations</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation is essentially the mixing in of the key and is what makes
the running of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm different depending on what key is used.
Firstly, in order to make reversal even more different, we <strong>create multiple new
keys from the original key</strong>. This is called the <a href="https://en.wikipedia.org/wiki/AES_key_schedule">AES key
schedule</a>. This walkthrough will
not go into detail on how this key-expansion works, but if interested one can
look up details. The part which is important to this walkthrough is that after
this expansion we have as many new keys as we have rounds. We will number all
the keys to form \(k_0\) to \(k_{10}\) (assuming we are using 128 bit
<a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>).  Here \(k_0\) is the original key and \(k_1\) till \(k_{10}\) are
the expanded keys.</p>
<p><img src="aes/../assets/AES_Key_Schedule.svg" alt="AES Key Schedule" /></p>
<p><em>Figure 1: The AES Key Schedule</em></p>
<p>With these keys we perform a <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> on a block. The <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation is a
notorious one way operation. This is due to the lack of information the output
shares about the input. When we do a one bit <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation, and we receive 1
as an output, the input could have been (0,1) or (1,0). We also have two options
when we get 0 as output. In the case of one bit, this is not that useful.
However, when we have a lot of bits the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operator is impossible to
instantly reverse for every output and brute forcing time is equal to trying
every option divided by two. Mathematically this caused by the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation
being non-<a href="https://en.wikipedia.org/wiki/Injective_function">injective</a>. When we have the outcome and one of the inputs however,
this step is extremely easy to reverse. These two properties make it ideal for a
lot of encryption algorithms.</p>
<p><img src="aes/../assets/XOR_NonInjectivity.svg" alt="XOR Non Injective" /></p>
<p><em>Figure 2: The non-<a href="https://en.wikipedia.org/wiki/Injective_function">injective</a> nature of the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation</em></p>
<h2 id="shuffling-of-bytes"><a class="header" href="#shuffling-of-bytes">Shuffling of bytes</a></h2>
<p>Next let us have a look at the other parts of each round. The shuffling of
the block bytes. <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>s have 3 distinct shuffling techniques:
<strong>substitution, shifting, and mixing</strong>. We are going to have a look at all three
of these shuffling techniques, but let us first have a look at how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael
block cipher</a>s view each block.</p>
<h3 id="block-of-blocks"><a class="header" href="#block-of-blocks">Block-of-blocks?</a></h3>
<p>Rijndael looks at blocks as a matrix of bytes. For the key sizes of key sizes of
128, 192 and 256 bits, we have 4 by 4, 6 by 6 and 8 by 8 matrices, respectively.
This would mean that a 128-bit key with bytes \(b_0, ..., b_{15}\) is turned
into \[
\begin{bmatrix}
b_0 &amp; b_4 &amp; b_8 &amp; b_{12} \\
b_1 &amp; b_5 &amp; b_9 &amp; b_{13} \\
b_2 &amp; b_6 &amp; b_{10} &amp; b_{14} \\
b_3 &amp; b_7 &amp; b_{11} &amp; b_{15}
\end{bmatrix}
\]
Turning a long string of bytes into a matrix allows for matrix operations, which
are common operations for computers. This provides both clarity and speed.</p>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<p>Now comes one of the most genius but strange parts of the Rijndael block
cipher. This is the substitution box. A substitution box is basically a lookup
table to replace (or substitute) a byte with the one from the lookup table. Some
demands for such a lookup table (when used in encryption algorithms) may be:</p>
<ul>
<li><strong>Reversible</strong>: In order to find back the original byte, we want to be able
to reverse the process.</li>
<li><strong>Non-Linear</strong>: In order to make resistant to
<a href="https://en.wikipedia.org/wiki/Linear_cryptanalysis">linear</a> and
<a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis">differential</a>
cryptanalysis, the lookup should be very difficult to approximate with a
linear function.</li>
<li><strong>Fixed Output Sizing</strong>: In order to reduce the complexity and loss of excess
data, we want to output to have a fixed bit size (preferably the same as the
input).</li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-Box</a> does all these things. Since it has all of these
properties, how it specifically looks is not important. Every implementation of
<a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> can save the Substitution-Box and its inverse in static memory since it is
public knowledge.</p>
<p>Here is the <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-Box</a> as a <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> array.</p>
<pre><code class="language-python"># Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]
</code></pre>
<h3 id="shifting"><a class="header" href="#shifting">Shifting</a></h3>
<p>The most plain, but equally important, round step is the shifting of the rows.
This step prevents the columns (4 consecutive bytes in the case of the 128 bit
variant) from being <strong>encrypted and decrypted separately</strong>. The step consists of
shifting the first row of the matrix by zero, the second by one, the third by
two and the fourth by three spaces. This is depicted in <em>Figure 3</em>.</p>
<p><img src="aes/../assets/Shift_Rows.svg" alt="Shift Rows" /></p>
<p><em>Figure 3: <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>'s Shift Row</em></p>
<h3 id="mixing"><a class="header" href="#mixing">Mixing</a></h3>
<p>The last shuffling step mixes the columns in order to create <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">cryptographic
diffusion</a>, which makes
it <strong>resistant to <a href="https://en.wikipedia.org/wiki/Frequency_analysis">statistical analysis
attacks</a></strong>. The step works by
multiplying each column with the following invertible matrix (multiplication
meaning modulo multiplication and addition meaning <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>): \[ \begin{bmatrix} 2
&amp; 3 &amp; 1 &amp; 1 \\ 1 &amp; 2 &amp; 3 &amp; 1 \\ 1 &amp; 1 &amp; 2 &amp; 3 \\ 3 &amp; 1 &amp; 1 &amp; 2
\end{bmatrix} \]</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Let us now provide an overview for how a typical <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> encryption looks. One can
imagine that the decryption is just the inverse of these actions we will
therefore gloss over that part.</p>
<p>As said before, the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> encryption process works in rounds. With every round
needing a separate expanded key. Therefore, the first step is to create these key
expansions as described in <a href="aes/workings.html#xor-operations">XOR Operations</a>. Immediately
following this we that the initial round key \(k_0\) and apply the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> with
it to each block.</p>
<p>After the summation with the initial round key we will start applying rounds (9,
11 and 13 rounds for key sizes 128, 192 and 256 bits, respectively). These
rounds apply steps in the following order: Firstly, we do a <a href="aes/workings.html#substitution">substitution with the
Rijndael S-Box</a>. Secondly, we <a href="aes/workings.html#shifting">shift the rows of the
matrix</a>. Thirdly, we <a href="aes/workings.html#mixing">mix the columns of the matrix up</a>.
Lastly, we <a href="aes/workings.html#xor-operations">add the round key for that round</a>.</p>
<p>If you are counting along, you will notice that the final round is missing. This
is because the final round is a little different. The only difference being
that we <strong>skip the <a href="aes/workings.html#mixing">mixing of
columns</a></strong> step, since it serves no purpose in the final round.</p>
<p>This all results in the following process:</p>
<ol>
<li><a href="aes/workings.html#xor-operations">Key Expansion</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_0\) by XOR</a></li>
<li>Apply 9, 11, or 13 rounds
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#mixing">Mix the columns</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by XOR with \(n\) being the round
number</a></li>
</ol>
</li>
<li>Final round
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by XOR with \(n\) being the round
number</a></li>
</ol>
</li>
</ol>
<p>After reading this section should have a basic overview and understanding of how
<a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works, which you will need for your <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a>. If you want a more
visual explanation of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm, you could watch <a href="https://www.youtube.com/watch?v=O4xNJsjtN6E">AES Explained by
Computerphile</a>.</p>
<h1 id="modeling-aes"><a class="header" href="#modeling-aes">Modeling AES</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Creating a leakage model for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></li>
<li>Implementing a leakage model for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a></li>
</ul>
</blockquote>
<p>In order to make sensible statements about the power usage of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, we are
going to make a <a href="aes/./cpa.html#leakage-models">leakage model</a> of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm.  To do this, we need
some to determine the optimal memory state to target. When we have determined
that state, we are going to implement that <a href="aes/./cpa.html#leakage-models">leakage model</a> in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>.</p>
<h2 id="hamming-distance-and-hamming-weight"><a class="header" href="#hamming-distance-and-hamming-weight">Hamming Distance and Hamming Weight</a></h2>
<p>Remember that we covered both the <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> and <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a>
hypotheses of looking at <a href="aes/./cpa.html#leakage-models">memory-based leakage model in Correlation Power
Analysis</a>. In this walkthrough, we are going to go through a
software implementation of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>. The <code>.hex</code> file of the algorithm for
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> targets can be found
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-aes">here</a>.
Since we are using a software implementation, this walkthrough is going to focus
on the <a href="aes/./cpa.html#hamming-weight">Hamming Weight-based leakage model</a>.</p>
<p>We can easily calculate <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming Weight</a> with the following lambda function.</p>
<pre><code class="language-python">HammingWeightFn = lambda x: bin(x).count('1')
</code></pre>
<p>Although it can be worth it to save this to memory, to speed to computation time
later on.</p>
<pre><code class="language-python"># Precompute Hamming Weight
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
</code></pre>
<h2 id="finding-a-memory-state"><a class="header" href="#finding-a-memory-state">Finding a memory state</a></h2>
<p>Suppose we have an input block <em>Input</em> and an output block <em>Output</em>,
which is a reasonably common situation. If we wanted to check whether a
supposed <em>Key</em> is the key used, we could run through the entire algorithm to
check whether \(\text{AES}(Input, Key) = Output\). This is quite inefficient
and is no better than brute forcing the key. Knowing what we know about the
memory state of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, we can however do two extreme optimizations.</p>
<h3 id="shortcutting-calculations"><a class="header" href="#shortcutting-calculations">Shortcutting calculations</a></h3>
<p>The first optimization we can do has to do with identifying the first memory
state where the key and the <em>Input</em> are combined. If we can identify this memory
state in the power trace, we can determine a probability a certain key was used.
There are two problems with this, however. Firstly, identifying the presence or
the location of this memory state is non-trivial. It is very difficult to
manually look at a power trace and tell something about memory states. This is
mostly due to the variances in baseline power consumption but also due to noise
and other factors. Some of these factors however can be nullified if we look at
multiple power traces instead of one. In order to make it even easier, we also
look at different input blocks. This allows us to shortcut calculation time by a
lot, since we don't have to do multiple rounds. But we still have to brute force
through every key option.</p>
<h3 id="limiting-the-amount-of-keys"><a class="header" href="#limiting-the-amount-of-keys">Limiting the amount of keys</a></h3>
<p>If we have done the first optimization, there is another optimization which
would lower the amount of possible keys. For the 128 (\(2^{128}\) different
keys), 192 (\(2^{192}\) different keys) and 256 (\(2^{256}\) different keys)
bits key variants, this leaves just \(2^{12}\), \((3 \cdot 2^{11})\) and
\(2^{13}\) key possibilities left, respectively. These are massive
differences, which allows us to break <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> in just a few seconds.</p>
<p>How does it work? Please read back <a href="aes/./workings.html#shifting">How AES Works -
Shifting</a> for one second and see if you find what we can
exploit, when have a value before this step happens. As it mentions this, the
step is needed to prevent <strong>attacking each column individually</strong>. Since we can
now produce a value before this step is done. We can attempt to break parts of
the key one at the time. The parts of this key are called sub-keys, and they are
1 byte in size. This means we can take the sum of different values for the
sub-keys instead of the product.</p>
<h2 id="putting-this-together"><a class="header" href="#putting-this-together">Putting this together</a></h2>
<p>Let us make a model of the memory states power usage. This model should provide
us with a number that should <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlate</a> with the power traces at the point of
which this first <a href="aes/./workings.html#substitution">SBox</a> step is done. This leaves us
with a longstanding memory state which is dependent on both the key and the
input string. Two items we both preferred for our <a href="aes/./cpa.html#leakage-models">leakage model</a> as explained in
<a href="aes/./cpa.html#memory-based-models">Memory-based models</a>. The <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code for
performing our model on a single byte input string using a single byte from the
key (also called a sub-key) is the following.</p>
<pre><code class="language-python">def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<h1 id="capture-multiple-traces"><a class="header" href="#capture-multiple-traces">Capture multiple traces</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Setting up our <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> <em>scope</em> and <em>target</em></li>
<li>Running <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> on our <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> <em>target</em></li>
<li>Performing a power trace of our algorithm</li>
<li>Saving multiple power traces to a file</li>
</ul>
</blockquote>
<p>Cracking the key used by <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> with <a href="https://en.wikipedia.org/wiki/Power_analysis">Power Analysis</a> is a lot more complex than
was the case with <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>. Looking at one trace of an <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> decryption can
potentially give you all the information you need to crack the private key.
With <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> and, more generally, with <a href="aes/./cpa.html">Correlation Power Analysis</a>, it is
necessary to perform multiple traces and average those power traces out. In this
section, we are going to have a look at how we can set up a <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> to
measure power traces. Afterwards, we are going to do some traces and learn how
to save them, so we can later do more detailed analysis on them.</p>
<blockquote>
<p><strong>Note:</strong> If you just want to move on with the analysis or don't have a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board at hand, you can download a pre-made power trace
over <a href="https://github.com/coastalwhite/intro-power-analysis/tree/main/datasets/aes/premade">here</a>.</p>
</blockquote>
<h2 id="setting-up-our-chipwhisperer-board"><a class="header" href="#setting-up-our-chipwhisperer-board">Setting up our ChipWhisperer board</a></h2>
<p>Assuming that you have correctly <a href="aes/../preparing.html">set up your software
environment</a>, we can start connecting and setting up our
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board. This is going to go in 2 steps:</p>
<ol>
<li>Fetching and setting up our scope</li>
<li>Setting up and programming our target</li>
</ol>
<h3 id="basics"><a class="header" href="#basics">Basics</a></h3>
<p>Before we actually start scripting, we are starting in the <a href="https://docs.python.org/3/tutorial/interpreter.html">Python
Interpreter</a>. We can get into the <a href="https://docs.python.org/3/tutorial/interpreter.html">Python Interpreter</a> from our shell using
the following command:</p>
<pre><code class="language-bash">python3
</code></pre>
<p>In order to then get started with the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Python Library, we can import
the library with:</p>
<pre><code class="language-python">import chipwhisperer as cw
</code></pre>
<p>If one gets an error here, verify that <a href="aes/../preparing/chipwhisperer.html">the ChipWhisperer Python library is
properly installed</a>. Otherwise, we can try to
connect our <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Capture board to our computer via USB and run the
following command to connect to the Capture board.</p>
<pre><code class="language-python">scope = cw.scope()
</code></pre>
<p>This should connect to our capture board. On some <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capture boards
an extra light might start flickering. If you get an error, there most probably
is something wrong with your connection. If you are on Linux, perhaps you have
to <a href="aes/../preparing/chipwhisperer.html#linux-udev-rules">set up some udev rules</a>.</p>
<p>Now we are going to set some settings used by the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board(s). For
now, we will just use the default settings. That works well enough for now, but
if you want an overview of the possible settings, look over
<a href="https://chipwhisperer.readthedocs.io/en/latest/api.html#openadc-scope">here</a>.
We can select the default settings using the following command.</p>
<pre><code class="language-python">scope.default_setup()
</code></pre>
<p>Then we have to fetch the <em>target</em> board. This is going to contain all the connections
and settings about the microprocessor which is going to execute our algorithm.
If you have hooked up your <em>target</em> — this is done automatically for the
<a href="https://www.newae.com/products/NAE-CWLITE-ARM">ChipWhisperer Lite boards</a> — you can use the following
command to fetch the <em>target</em> object.</p>
<pre><code class="language-python">target = cw.target(scope)
</code></pre>
<p>Now in order to safely disconnect our <em>target</em> and <em>capture</em> board, and we can
use the following two commands.</p>
<pre><code class="language-python">scope.disconnect()
target.disconnect()
</code></pre>
<p>Now we know the basics of how to set up and interact with the connection between
our computer and the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board.</p>
<h3 id="scripting"><a class="header" href="#scripting">Scripting</a></h3>
<p>We know some basic commands, so we can actually start scripting. We create a
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> file, and put the basic commands — we just learned — into
it.</p>
<p>This is what it will look like.</p>
<pre><code class="language-python">import chipwhisperer as cw

# Setup a connection with the CW board
# and fetch the scope for using this board.
scope = cw.scope()

# The default settings are fine for now.
scope.default_setup()

# Fetch the target from the scope
# This should be automatically connected
target = cw.target(scope)

#
# We do our logic here!
#

scope.dis()
target.dis()
</code></pre>
<p>Running this script using the <code>python3 file-name.py</code> command should work just
fine and now we can start actually working with an encryption algorithm.</p>
<h3 id="uploading-the-algorithm-source-code"><a class="header" href="#uploading-the-algorithm-source-code">Uploading the algorithm source code</a></h3>
<p>Depending on what target we are using, we need to upload different software. We
can <a href="aes/../compiling.html">compile this software ourselves</a>, but a lot of compiled
code can also be found online. The compiled code for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> can be found
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-aes">here</a>.</p>
<blockquote>
<p><strong>Note:</strong> This walkthrough will demonstrate the process of uploading source
code for the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">ChipWhisperer Lite ARM board</a>, although many of the
concepts here can also be applied to other boards. More information on other
uploading source code for other targets can be found
<a href="https://chipwhisperer.readthedocs.io/en/latest/api.html#program">here</a>.</p>
</blockquote>
<p>In order to upload a binary to the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite ARM</a>, we will use the <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel Hex
format</a>. Therefore, assuming we are
using the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Lite 32-bit ARM-edition, we can the <code>CWLITEARM</code> hex
file provided in the <a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-aes">SimpleSerial AES GitHub folder</a>.
Assuming we have downloaded that <code>.hex</code> file and put it into a folder called
<code>hexfiles</code> we can use the following <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code to upload the program to our
<em>target</em>.</p>
<pre><code class="language-python"># ... Connecting to the scope / target

from chipwhisperer.capture.api.programmers import STM32FProgrammer
import os

# Initiate a new STM32F Program
# STM32 being the ARM microcontroller that we are using
# https://en.wikipedia.org/wiki/STM32#STM32_F3
program = STM32FProgrammer

# Get the path to the current folder
# Adjust accordingly
aes_firmware_dir = os.path.dirname(os.path.realpath(__file__))
aes_hex_path = os.path.join(aes_firmware_dir, r&quot;hexfiles/simpleserial-aes-CWLITEARM.hex&quot;)

# Apply the program to the actual target
# This allows us to run the hex code on the microcontroller
cw.program_target(scope, program, aes_hex_path)

# ... Disconnecting from the scope / target
</code></pre>
<p>Now that we have uploaded our program to the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> target board, we
start capturing traces.</p>
<h2 id="capturing-a-trace"><a class="header" href="#capturing-a-trace">Capturing a trace</a></h2>
<p>In order to run our first trace, we need a key and some plain text. The program
we are using is based on <em>128-bit AES</em>, and, therefore, we should provide a
128-bit key and a multiple or 128 bits for our plain text. We can quite easily
create our first trace, with the following code.</p>
<pre><code class="language-python"># Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'H4ck3rm4n-l33t42'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the plain text used
# This plain text has to be a multiple of
# 128 bits = 16 bytes = 16 ascii characters in length.
plain_text = bytearray('a' * 16, 'ascii')

# Capture the actual trace
trace = cw.capture_trace(scope, target, plain_text, key)
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Within the <a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">SimpleSerial</a> protocol — which is used under the
hood by the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> devices — the
<a href="https://chipwhisperer.readthedocs.io/en/latest/api.html?highlight=capture_trace#chipwhisperer.capture_trace"><code>capture_trace</code></a>
function corresponds with a couple of steps (arming the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>,
sending the key/plaintext and retrieving the trace data, etc.). This can
become important when implementing your own algorithms. There it may be
important to replace this one function with its individual steps to get more
control over the commands send. This can be seen in the <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code of the
<a href="https://github.com/coastalwhite/simpleserial-c-template">SimpleSerial C
template</a>.</p>
</blockquote>
<p>This is very interesting, but we don't really have any confirmation or
visualization. So let us visualize it with <a href="https://matplotlib.org/">matplotlib</a>.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(trace.wave)
plt.show()
</code></pre>
<p>This should look something like <em>Figure 1</em>.</p>
<p><img src="aes/../assets/aes_single_trace_plot.png" alt="AES Single Power Trace" /></p>
<p><em>Figure 1: <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> Single Power Trace</em></p>
<h2 id="capturing-more-than-one-trace"><a class="header" href="#capturing-more-than-one-trace">Capturing more than one trace</a></h2>
<p>We can turn this into multiple traces with a simple <code>for</code> loop. Here we are
going to be using the <a href="https://github.com/tqdm/tqdm">TQDM</a> library to have a nice progress bar. So let us
create 100 traces with random input text and save all relevant data into a
<a href="https://numpy.org/">numpy</a> arrays.  This way we can save the eventual traces and plain texts to a
file.</p>
<p>First we define a function for creating random plain text strings.</p>
<pre><code class="language-python">import string
import random

def random_string(length):
    # Define the alphabet of the random string
    # Here we take the lowercase latin alphabet in ascii encoding
    # e.g. &quot;cpjsapcnrsdtjvlo&quot;, &quot;btqfocsprbualtwt&quot; or &quot;yzkwewjbkpmriccx&quot;
    alphabet = string.ascii_lowercase

    # Return a string with the given length with randomly chosen chars
    return ''.join(random.choice(alphabet) for i in range(length))
</code></pre>
<p>Then we capture some traces.</p>
<pre><code class="language-python">from tqdm import trange

# Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'H4ck3rm4n-l33t42'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the constant for the amount of traces
N = 100

textins = []
traces = []

# Loop through all traces
for i in trange(N, desc=&quot;Capturing traces&quot;):

    # Define the plain text used
    # This plain text has to be a multiple of
    # 128 bits = 16 bytes = 16 ascii characters in length.
    plain_text = bytearray(random_string(16), 'ascii')

    # Capture the actual trace
    trace = cw.capture_trace(scope, target, plain_text, key)

    # If the capture timed out move to the next capture
    if trace is None:
        continue

    textins.append(plain_text)
    traces.append(trace.wave)
</code></pre>
<p>Then we turn this into numpy arrays.</p>
<pre><code class="language-python">np_traces = np.asarray(traces)
np_textins = np.asarray(textins)
</code></pre>
<p>Then we can save it to a file.</p>
<pre><code class="language-python">np.save('output/traces.npy', np_traces)
np.save('output/textins.npy', np_textins)
</code></pre>
<p>This way we can later load it.</p>
<blockquote>
<p>For more information on how to do scripting with the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python
module have a look over <a href="https://wiki.newae.com/Making_Scripts">here</a>.
<strong>Disclaimer:</strong> This is quite heavy.</p>
</blockquote>
<p>We have now correctly set up our <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> equipment, uploaded the
source code of the encryption algorithm we are using to the target, captured
power traces of the target and saved those power traces to a file on our system.
Now, we are ready to do some analysis on those power traces.</p>
<h1 id="crack-individual-key-byte"><a class="header" href="#crack-individual-key-byte">Crack individual key-byte</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Loading our saved power traces</li>
<li>Calculating <a href="aes/./cpa.html#pearson-correlation-coefficients">Pearson correlation
coefficients</a> in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a></li>
<li>Finding the highest <a href="aes/./cpa.html#pearson-correlation-coefficients">Pearson correlation
coefficient</a> for a byte of the key used</li>
</ul>
</blockquote>
<p>After creating files containing multiple power traces in the <a href="aes/./capture.html">previous
section</a>, we can now start analyzing our traces and attempt to
crack some bytes with the leakage model we defined in <a href="aes/./modeling.html">Modeling
AES</a>.</p>
<p>So what did we have for our leakage model up until now?</p>
<pre><code class="language-python">HammingWeightFn = lambda x: bin(x).count('1')

# Precompute Hamming Weight
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<p>We are going to take this as a starting point of a new <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> script. This
walkthrough is will refer to that <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> file as <code>crack.py</code>. We can thus run
this script from our shell using <code>python3 crack.py</code>.</p>
<h2 id="loading-back-in-our-traces"><a class="header" href="#loading-back-in-our-traces">Loading back in our traces</a></h2>
<p>In order to load the power traces we created in the <a href="aes/./capture.html">previous
section</a>, we can add the follow few lines which will load in the
<a href="https://numpy.org/">NumPy</a> arrays. The traces here are put into a subfolder called <code>output</code>. If for
any reason making power traces did not work out, or you don't own a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> board, but you still want to continue, you can download some
pre-made traces from
<a href="https://github.com/coastalwhite/intro-power-analysis/tree/main/datasets/aes/premade">here</a>.</p>
<pre><code class="language-python">import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

</code></pre>
<p>Now we can use our from the <code>traces</code> variable, we know how many traces we have
(<code>num_traces</code>), and how many points in time we have per trace (<code>num_points</code>).</p>
<h2 id="implementing-pearson-correlation-coefficients"><a class="header" href="#implementing-pearson-correlation-coefficients">Implementing Pearson Correlation Coefficients</a></h2>
<p>As explained in the section on <a href="aes/./cpa.html">Correlation Power Analysis</a>, we are
going to be using <a href="aes/./cpa.html#pearson-correlation-coefficients">Pearson Correlation Coefficients</a> to detect whether
our power trace is similar to our leakage model. So let us implement <a href="aes/./cpa.html#pearson-correlation-coefficients">Pearson
Correlation Coefficients</a> in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>.</p>
<pre><code class="language-python">def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
</code></pre>
<p>Although this code is very inefficient, and does a lot of unnecessary and double
calculations, it will serve well for now. We are going to be optimizing this
code in <a href="aes/./optimization.html">Sidenote: optimizing our code</a>.</p>
<h2 id="cracking-a-single-byte-of-the-key"><a class="header" href="#cracking-a-single-byte-of-the-key">Cracking a single byte of the key</a></h2>
<p>As explained in <a href="aes/./modeling.html">Modeling AES</a>, we can — using <a href="https://en.wikipedia.org/wiki/Power_analysis">power analysis</a> —
<strong>crack the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> key byte by byte</strong>. So let us start with a single one. We are
going to go through every possibility and see which byte one provides the
highest <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a> between the actual power trace and our modeled
power usage. The important realization here is that we are doing a correlation
between all individual power trace points and the hypothetical power
consumption, and we will select the maximum correlation coefficient for all
sub-key guesses.  This is because we still have no idea where within the power
trace the first round actually takes place. If we look at all points of each
power trace, the location where the first round takes place should have the
highest correlation.  We will demonstrate this later on.</p>
<pre><code class="language-python">from tqdm import trange

def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation

# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
</code></pre>
<p>This will determine the maximum [correlation coefficients] for all sub-key guesses.
If we plot this we get the following graph.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
</code></pre>
<p><img src="aes/../assets/aes_max_correlation_coefficients.png" alt="Maximum Correlation Coefficients AES" /></p>
<p><em>Figure 1: The <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> Correlation Coefficients for the first sub-key values</em></p>
<p>Remember I used the key <code>H4ck3rm4n-l33t42</code>, where <code>H</code> or ASCII 72 is the first
sub-key byte. If you used a different key, your plot will most probably look
different and there will be a high spike at the ASCII value of your first
sub-key.</p>
<p>Well done! We have cracked our first sub-key! Now that we know how to load in
our power traces, and we have successfully cracked one of the bytes of the
encryption key, we can move on to cracking the entire key.</p>
<h1 id="automate-the-cracking-process"><a class="header" href="#automate-the-cracking-process">Automate the cracking process</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Automatically selecting which sub-key fits best</li>
<li>Cracking the entire key</li>
</ul>
</blockquote>
<p>In this section, we are going to expand upon the <a href="aes/./key-bytes.html">previous
section</a> by automating the cracking process for single bytes and
then making the process work on the entire key. Most of what is discussed in
this section is quite trivial. If you feel quite comfortable with what was
discussed in the previous sections, by all means skip this section and attempt
to implement these behaviors yourself. If you get stuck, you can always come
back here for a hint.</p>
<h2 id="where-were-we"><a class="header" href="#where-were-we">Where were we?</a></h2>
<p>At the moment, we have code for modeling the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> memory state based power
consumption, calculating <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficients</a>
between our leakage model and the power traces and a piece of code to plot our
results. This is how that all looks together.</p>
<pre><code class="language-python">import numpy as np
from tqdm import trange

# Modeling the power consumption
########################################
HammingWeightFn = lambda x: bin(x).count('1')

# Precompute Hamming Weight
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
########################################

# Loading our trace data
########################################
import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

########################################

# Pearson correlation
########################################
def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
########################################

# Define a function to calculate the Correlation Coefficients for a byte in a
# subkey.
########################################
def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation
########################################

# Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Plotting the max_correlation_coefficients
########################################
import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
########################################
</code></pre>
<h2 id="automatically-picking-the-best-sub-key-guess"><a class="header" href="#automatically-picking-the-best-sub-key-guess">Automatically picking the best sub-key guess</a></h2>
<p>Currently, we plot the graph of the maximum <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation
coefficients</a>, and we determine from there what the
correct option is. We can easily automate this process from the observation that
the correct option has the highest <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>. To select this
option, we can use the <a href="https://numpy.org/doc/stable/reference/generated/numpy.argmax.html">numpy
<code>argmax</code></a>
function.</p>
<p>Replace the code for plotting with the following code.</p>
<pre><code class="language-python"># Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex value and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
</code></pre>
<p>Now the code will automatically print out the option with the highest
<a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>.</p>
<blockquote>
<p><strong>Note:</strong> If we have done only a few traces and our <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation
coefficients</a> are a bit less reliable, we can use
<a href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html?highlight=argsort#numpy.argsort"><code>np.argsort(...)[::-1]</code></a>
multiple good options. With these options we can then, for example, try to
brute force our key with the top 5 best options.</p>
</blockquote>
<h2 id="cracking-the-entire-key"><a class="header" href="#cracking-the-entire-key">Cracking the entire key</a></h2>
<p>Cracking the entire key is as easy as adding another <code>for</code> loop.  This loop will
go through all sub-keys and pick the best guess for each sub-key.</p>
<p>This will turn the first piece of code into the second piece of code.</p>
<pre><code class="language-python"># Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Printing the best guess
########################################
# Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex value and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
########################################
</code></pre>
<pre><code class="language-python"># Looping through all subkeys
########################################
# The eventual key guess
best_guess = np.zeros(16)

# Loop through all possible subkeys
for subkey_index in trange(16, desc=&quot;Subkey Index&quot;):
    # Save all correlation coefficients
    max_correlation_coefficients = np.zeros(256)

    # Loop through values this subkey
    for subkey in range(0x00, 0xff + 1):
        max_correlation_coefficients[subkey] = max(abs(
            calculate_correlation_coefficients(subkey, subkey_index)
        ))
    
    # Save the best guess
    best_guess[subkey_index] = np.argmax(max_correlation_coefficients)
########################################

# Printing the best guess
########################################
print(&quot;Best guess:&quot;)
for b in best_guess: print(&quot;{:02x} &quot;.format(int(b)), end=&quot;&quot;)
print(&quot;&quot;)
for b in best_guess: print(&quot;{}&quot;.format(chr(int(b))), end=&quot;&quot;)
print(&quot;&quot;)
########################################
</code></pre>
<blockquote>
<p><strong>Note:</strong> Currently, our code is not very efficient and thus is might take
quite a bit of time for it to crack the entire key. This will be optimized in
<a href="aes/./optimization.html">Sidenote: optimizing our code</a>.</p>
</blockquote>
<p>This should output the following.</p>
<pre><code class="language-text">Best guess:
48 34 63 6b 33 72 6d 34 6e 2d 6c 33 33 74 34 32
H4ck3rm4n-l33t42
</code></pre>
<p>Correct! This was indeed the key we used to produce our power traces!</p>
<p>We have now successfully cracked the full encryption key from an implementation
of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>. We can calculate the best suiting sub-key for each byte of the key and
then combine them all together into one by looping over the bytes. Good job!</p>
<h1 id="sidenote-optimizing-our-code"><a class="header" href="#sidenote-optimizing-our-code">Sidenote: Optimizing our code</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Optimizing the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson Correlation Coefficient</a> calculations</li>
</ul>
</blockquote>
<p>As you may have noticed our algorithm is now really slow. This is due to the
calculation of <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson Correlation Coefficient</a>s. We can speed this up by a lot
if we notice a couple of things.</p>
<ol>
<li>\(\sqrt{a}\sqrt{b}=\sqrt{a b}\). Since square rooting is a very expensive
operation, we can optimize the calculation of \(\sigma_x \sigma_y\) from
two square root calculations to one.</li>
<li>We are recalculating a lot of averages and standard deviations. We can
pre-compute these averages and <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>s and fetch them instead
of recomputing them.</li>
<li>Since we only care about the maximum <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a> and have no
interest in the value itself, we can stop doing any factorization.</li>
</ol>
<p>In the following code we have created a function which applies these three
optimized functions when calculating the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficients</a>.</p>
<pre><code class="language-python">point_means = np.mean(traces, axis=0, dtype=np.float64)
point_mean_diff = traces - point_means

point_mean_diff_squared_sum = np.sum(np.power(point_mean_diff, 2), axis=0)

def optimized_calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    hypothetical_power_mean = np.mean(hypothetical_power, dtype=np.float64)
    hypothetical_power_mean_diff = hypothetical_power - hypothetical_power_mean

    hypothetical_power_mean_diff_sum_squared = np.sum(
        np.power(hypothetical_power_mean_diff, 2)
    )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = np.sum(
            hypothetical_power_mean_diff *

            # Look at the individual traces points for every trace
            point_mean_diff[:, point_index]
        ) / np.sqrt(hypothetical_power_mean_diff_sum_squared *
                point_mean_diff_squared_sum[point_index])

    return point_correlation
</code></pre>
<p>After optimizing the calculations of the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation
coefficients</a>, our <code>crack.py</code> script should run a lot
faster.</p>
<h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>Here are some small exercises to verify you understand the material covered.</p>
<ol>
<li>At the following
<a href="https://github.com/coastalwhite/intro-power-analysis/tree/main/datasets/aes">location</a>
you can find 3 sets of power traces, can you crack their keys used? You will
know when you cracked them.</li>
<li>Does the method of correlation power analysis
apply to the <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha ciphers</a>. Why
does it work? Why does it not work?</li>
</ol>
<h1 id="compiling-your-own-algorithms"><a class="header" href="#compiling-your-own-algorithms">Compiling your own algorithms</a></h1>
<blockquote>
<p><strong>What will this chapter cover?</strong></p>
<ul>
<li>Installing toolchains necessary for compiling code for a <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>
target</li>
<li>Getting started with the SimpleSerial protocol</li>
<li>Some useful resources for target algorithms</li>
</ul>
</blockquote>
<p>This walkthrough provides sources for most of the precompiled code you might
need. However, in order to some experimentation yourself, you might want to
compile some implementation of an algorithm. To do this, there are two things we
need: the toolchain to compile to our specific microprocessor architecture and
the low-level source code to compile.</p>
<p>The following section will cover how to install the toolchains for the ARM
architecture. Following that section, will some things to keep in mind when
writing source code for our target. Then, there will be a section on some useful
resources concerning <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> and algorithms for our target.</p>
<h1 id="installing-toolchains"><a class="header" href="#installing-toolchains">Installing Toolchains</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>Installing the ARM toolchain</li>
<li>Compiling code</li>
</ul>
</blockquote>
<p>In order to compile code which is usable for our specific microprocessor
architecture, we need the toolchain for that specific architecture. As said in
the <a href="compiling/../intro.html">introduction chapter</a>, this walkthrough is using the
<a href="https://www.newae.com/products/NAE-CWLITE-ARM">ChipWhisperer Lite ARM</a> board. Therefore, this section will show
how to install the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM toolchain</a>. For other toolchains, have a look at the
<a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#compilers">ChipWhisperer
documentation</a>.</p>
<h2 id="installing-the-arm-toolchain"><a class="header" href="#installing-the-arm-toolchain">Installing the ARM toolchain</a></h2>
<p>Information on the ARM toolchain can be found
<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">here</a>.</p>
<h3 id="windows-and-macos"><a class="header" href="#windows-and-macos">Windows and macOS</a></h3>
<p>For <em>Windows</em> and <em>macOS</em>, the installer on the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM developer
website</a>
should be enough to install the ARM embedded toolchain.</p>
<h3 id="gnulinux-2"><a class="header" href="#gnulinux-2">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, we can use the following command
to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo apt install gcc-arm-none-eabi
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, we can use the following
command to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo pacman -S arm-none-eabi-gcc
</code></pre>
<h2 id="compiling-binaries"><a class="header" href="#compiling-binaries">Compiling binaries</a></h2>
<p>With the proper toolchain installed, we can compile binaries which are going to
be used on <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> <em>targets</em>. All SimpleSerial resources mentioned in
the <a href="compiling/./resources.html">Existing resources</a> section contain a <em>Makefile</em> in their
root directory. This file provides the computer instructions on how to compile
source code. In order to create <code>.hex</code> files — which is the format used to
program <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> targets — from our source, we can simply run the
following command from the root directory of our project, replacing <code>&lt;PLATFORM&gt;</code>
with the <a href="https://raw.githubusercontent.com/coastalwhite/simpleserial-c-template/main/PLATFORMS.md">proper
platform</a>.</p>
<pre><code class="language-bash">PLATFORM=&lt;PLATFORM&gt; make
</code></pre>
<p>This should create the <code>.hex</code> file in the root directory.</p>
<p>We have now installed the proper toolchain and learned how to compile our own
source code. Next up, we want to know how to properly write our source code, so
we can best do our measurements.</p>
<h1 id="simpleserial-protocol"><a class="header" href="#simpleserial-protocol">SimpleSerial protocol</a></h1>
<blockquote>
<p><strong>What will this section cover?</strong></p>
<ul>
<li>What is the SimpleSerial protocol?</li>
<li>How to we write source code?</li>
<li>How do we trigger power traces to start and stop?</li>
</ul>
</blockquote>
<p>In order to run your own algorithms, they first have to be written as source
code. The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework mostly uses <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a> as the language for the
source code of encryption algorithms. This means that any existing <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a>
implementation of an encryption algorithms can (most of the time) easily be used
on the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> targets. There are a few things to take into account,
however. The protocol to send data back and forth between the capture board and
the target board, some recommendations when writing or choosing software,
and how to start and stop power traces. These will all be covered here.</p>
<h2 id="the-simpleserial-protocol"><a class="header" href="#the-simpleserial-protocol">The SimpleSerial Protocol</a></h2>
<p>In order to send data back and forth between the capture board and the target
board and tell the target to start running its algorithm, a specific
protocol is often used by <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>. It is called the <a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">SimpleSerial
protocol</a>. It basically explains how to send data to the target
(such as keys, plain texts, commands, etc.) and return data back from the target
(such as cipher texts, hashes, errors, etc.). Some documentation on the <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a>
implementation of the algorithm can be found
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial">here</a>.
Although, if you use either the official
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-base">simpleserial-base</a>
or the
<a href="https://github.com/coastalwhite/simpleserial-c-template">simpleserial-c-template</a>,
you almost don't need to worry about the specifics.</p>
<h2 id="writing--selecting-your-code"><a class="header" href="#writing--selecting-your-code">Writing / selecting your code</a></h2>
<p>When writing your own algorithms for the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>, it is recommended to
either not use the heap or use it sparingly. Most of the boards used as targets
by <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> don't have a lot of RAM and thus using it sparingly is
preferred.</p>
<p>Also, when selecting existing implementations, it is recommended to use
embedded hardware or heapless implementations.
<a href="https://github.com/ARMmbed/mbedtls">MBedTLS</a> contains some of the more used
encryption algorithms.</p>
<h2 id="starting--stopping-power-traces"><a class="header" href="#starting--stopping-power-traces">Starting / Stopping power traces</a></h2>
<p>On the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">ChipWhisperer Lite ARM</a> and on many other boards, we use the
<code>trigger_high</code> function to start a power trace and the <code>trigger_low</code> to stop a
power trace. Both of these functions are available from the <code>hal.h</code>, which is
also used by the <a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">SimpleSerial protocol</a>.</p>
<p>This means somewhere in your code it should look something like the following.</p>
<pre><code class="language-c">// ...

trigger_high();

encrypt(...);
// or
decrypt(...);

trigger_low();

// ...
</code></pre>
<p>This way your entire encryption or decryption will be captured by the power
trace. You can also move the triggers to a specific point of the encryption or
decryption, if you want to focus on a specific part of the algorithm.</p>
<p>This should give you most of the information needed to write and/or compile your
own implementations of algorithms. The next section will contain some other
resources which can help you in this process.</p>
<h1 id="existing-resources"><a class="header" href="#existing-resources">Existing resources</a></h1>
<h2 id="information-on-the-simpleserial-protocol"><a class="header" href="#information-on-the-simpleserial-protocol">Information on the SimpleSerial protocol</a></h2>
<ul>
<li><a href="https://github.com/newaetech/chipwhisperer/blob/develop/hardware/victims/firmware/simpleserial/README.md">SimpleSerial
README</a></li>
<li><a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">ChipWhisperer
docs</a></li>
</ul>
<h2 id="templates-for-source-code"><a class="header" href="#templates-for-source-code">Templates for source code</a></h2>
<ul>
<li><a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-base">SimpleSerial
Base</a></li>
<li><a href="https://github.com/coastalwhite/simpleserial-c-template">SimpleSerial C
Template</a>: written
for this walkthrough</li>
</ul>
<h2 id="specific-algorithm-implementation-with-simpleserial"><a class="header" href="#specific-algorithm-implementation-with-simpleserial">Specific algorithm implementation with SimpleSerial</a></h2>
<ul>
<li><a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/">All list of firmware provided by the
framework</a>:
all the directories starting with <code>simpleserial-</code> can be used.</li>
<li><a href="https://github.com/coastalwhite/chipwhisperer-nist-lwc"><strong>COMING SOON:</strong> SimpleSerial wrapper for NIST Lightweight Cryptography
algorithms</a></li>
</ul>
<h2 id="useful-c-algorithm-implementations"><a class="header" href="#useful-c-algorithm-implementations">Useful C algorithm implementations</a></h2>
<ul>
<li><a href="https://github.com/ARMmbed/mbedtls">MBedTLS</a>: contains implementations for a
lot of the common algorithms</li>
<li><a href="https://www.oryx-embedded.com/doc/chacha_8c_source.html">ChaCha C
implementation</a></li>
</ul>
<h1 id="assignment"><a class="header" href="#assignment">Assignment</a></h1>
<p>As a final assignment for this walkthrough, there should a detailed report on some
component of power analysis including a demonstration and what effect it has on
possible attack vectors. A few categories of what we can look at along with some
example topics:</p>
<ul>
<li>Breaking an encryption algorithm which is not demonstrated in this walkthrough.
Possibly combined with some protections against power analysis. Have a look at
the <a href="./preparing/toolchains.html">Compiling your own algorithms</a> instructions.
Some examples of interesting algorithms are:
<ul>
<li>Breaking the <a href="https://en.wikipedia.org/wiki/Curve25519">Ed25519</a>
algorithm and providing some protections against power analysis. (Have a look
at the <a href="https://github.com/orlp/ed25519">following implementation</a>)</li>
<li>Breaking <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha</a> stream ciphers and
providing some protections against power analysis. (Have a look at the
<a href="https://www.oryx-embedded.com/doc/chacha_8c_source.html">following implementation</a>)</li>
</ul>
</li>
<li>Providing multiple protections on <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> or <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> along with analysis of their
effectiveness and remaining attack vectors.</li>
<li>Breaking algorithms by using the data power analysis provides us in new ways.
<ul>
<li>Apply machine learning to the data provides by a power-trace of an
encryption algorithm and determine its effectiveness.</li>
<li>Look further into optimizing the amount of power traces needed to do a correlation
power analysis attack. How many traces can reliably crack a certain
algorithm? Can this be improved in some way?</li>
</ul>
</li>
</ul>
<p>These are just a few examples within the many possible topics. If another
creative idea pops up, feel free to give it a shot. The only requirements of the
report are a <strong>reproducible demonstration and explanation of your method</strong> and a
<strong>description of (remaining) attack vectors through power analysis</strong>.</p>
<h2 id="grading--what-will-be-looked-at"><a class="header" href="#grading--what-will-be-looked-at">Grading / What will be looked at</a></h2>
<p>There are a few important topics to which is going to be paid attention whilst
grading.</p>
<h3 id="complexity-and-creativity-of-method"><a class="header" href="#complexity-and-creativity-of-method">Complexity and creativity of method</a></h3>
<p>Most important is the complexity and creativity of your method. These are best
formulated by the following two questions:</p>
<ol>
<li>What level of difficulty is your attack vector or method of execution?</li>
<li>How much of this method was already pre-done by other people?</li>
</ol>
<p>This also leads to the point that <strong>it is very important to cite sources for
your attacks.</strong> Any found plagiarism will <strong>not</strong> be tolerated. If one uses a
piece of text, code or method (almost) directly copied or cited from a source,
cite that (primary) source. If one adapts a piece of text, code or method from a
source, cite as <code>Adapted from ...</code>.</p>
<h3 id="level-of-explanation-and-writing"><a class="header" href="#level-of-explanation-and-writing">Level of explanation and writing</a></h3>
<p>Apart from having a great and creative method, it is also very important to make
clear why and why your method was so great and creative. Go into depth on the
steps of your method and why those steps help reach the desired result. You can
assume that the reader has also followed this walkthrough and albeit has some
preliminary knowledge.</p>
<h3 id="reproducibility"><a class="header" href="#reproducibility">Reproducibility</a></h3>
<p>The final important part of your assignment on <a href="https://en.wikipedia.org/wiki/Power_analysis">power analysis</a> is going to be
reproducibility.  How easy is it for the people checking your assignment to
reproduce your method(/results). Is your code readable? Is there some clear
documentation on compiling code, executing an attack or installing dependencies?
It is not needed to write step-by-step instructions yourself for most of these
steps, but it is important to write an overview on installing dependencies
(linking to the installation guide of that dependency), compiling instructions
(when needed) and attack execution instructions.</p>
<p>Good luck and have fun!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
