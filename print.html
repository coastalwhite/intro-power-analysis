<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Power analysis Introductory Walkthrough</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="preparing.html"><strong aria-hidden="true">2.</strong> Preparing your environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="preparing/python-pip.html"><strong aria-hidden="true">2.1.</strong> Python and Pip</a></li><li class="chapter-item expanded "><a href="preparing/chipwhisperer.html"><strong aria-hidden="true">2.2.</strong> ChipWhisperer</a></li><li class="chapter-item expanded "><a href="preparing/toolchains.html"><strong aria-hidden="true">2.3.</strong> Compiling your own algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="rsa.html"><strong aria-hidden="true">3.</strong> A case study: RSA</a></li><li class="chapter-item expanded "><a href="aes.html"><strong aria-hidden="true">4.</strong> Breaking AES</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="aes/workings.html"><strong aria-hidden="true">4.1.</strong> How AES works</a></li><li class="chapter-item expanded "><a href="aes/capture.html"><strong aria-hidden="true">4.2.</strong> Capturing multiple traces</a></li><li class="chapter-item expanded "><a href="aes/modeling.html"><strong aria-hidden="true">4.3.</strong> Modeling AES</a></li><li class="chapter-item expanded "><a href="aes/manual-analysis.html"><strong aria-hidden="true">4.4.</strong> Manual analysis</a></li><li class="chapter-item expanded "><a href="aes/pearson.html"><strong aria-hidden="true">4.5.</strong> Pearson correlation</a></li><li class="chapter-item expanded "><a href="aes/entire.html"><strong aria-hidden="true">4.6.</strong> Automatically cracking an entire key</a></li><li class="chapter-item expanded "><a href="aes/optimization.html"><strong aria-hidden="true">4.7.</strong> Sidenote: Optimizing our algorithm</a></li><li class="chapter-item expanded "><a href="aes/exercises.html"><strong aria-hidden="true">4.8.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="assignment.html"><strong aria-hidden="true">5.</strong> Assignment</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Power analysis Introductory Walkthrough</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/coastalwhite/intro-power-analysis" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="power-analysis-introductory-walkthrough"><a class="header" href="#power-analysis-introductory-walkthrough">Power Analysis Introductory Walkthrough</a></h1>
<p>IT Security has many fields and layers, all of which aim to investigate how to
break and protect the core principles of information security. These principles
are confidentiality, integrity and availability<sup class="footnote-reference"><a href="#tenets">1</a></sup>. One of these fields is
<a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel analysis</a>. Here the focus lies on how technology interacts with the
world around it, and what analysis those interacts can tell us about
calculations or operations done by the technology.</p>
<p>One of the techniques within <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel analysis</a> which aims break
confidentiality is <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a>. <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> looks at the power
consumption of hardware in order to make statements about the specific
calculations done within a computer. Some calculations require a higher amount
of power than other calculations.</p>
<p>Take a look at the following picture. If we know that the following <em>Figure 1</em>
records the a sequence of two different computations - namely, squaring and
taking a product - and we also know that squaring takes marginally less time
than taking a product in this case. You could hypothesize where the power trace
is taking a product and where the trace is squaring a number.</p>
<p><img src="./assets/power_analysis.png" alt="Power Analysis of RSA" /></p>
<p><em>Figure 1: Power Trace of a <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> encryption by
<a href="https://en.wikipedia.org/wiki/Power_analysis#/media/File:Power_attack_full.png">Audriusa</a>
(GPFL)</em></p>
<h2 id="purpose-of-this-walkthrough"><a class="header" href="#purpose-of-this-walkthrough">Purpose of this walkthrough</a></h2>
<p>This walkthrough is meant to be an introduction into both power analysis and
using the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework.  It expects you to have some basic
knowledge of <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> and probably <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a>.  It also helps to be comfortable with a
terminal and the shell. This walkthrough is not about programming or the shell,
however, and most of what is discussed could be followed along with, even if you
have very little programming experience. There is, however, a lot of pseudocode.</p>
<p>Furthermore, if you plan on doing your own traces, you will need a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board. This walkthrough will provide predefined data
sets so you can do some of the analysis without doing the traces yourself. This
could save you from buying a <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board. It is, however,
highly recommended to do some traces yourself. If you are looking at buying a
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> capturing board and don't know what to use, this walkthrough is
created using on the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite ARM</a> variant. It is a relatively cheap all-in-one
solution.</p>
<h2 id="chipwhisperer"><a class="header" href="#chipwhisperer">ChipWhisperer</a></h2>
<p>Normally, to make these power measurements on microprocesors, you need a lot of
expensive equipment.  Equipment such as multimeters, oscilloscopes, different
microcontrollers, connectors, etc. This is where the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> comes in.
The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework provides microcontrollers to test and run you
algorithms on, which are referred to as <em>targets</em>. But also provides
measurement devices, which when put together with a target is referred to as a
<em>scope</em>. <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> goes further than a playground and can be used in
real world environments, which makes an ideal framework to learn power analysis
with. Partially because scopes can also be connected to other unrelated
microprocesors in order to do power measurements on those.</p>
<div class="footnote-definition" id="tenets"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.lbmc.com/blog/three-tenets-of-information-security/">Three Tenets of Information Security by Mark
Burnette</a></p>
</div>
<h1 id="preparing-your-environment"><a class="header" href="#preparing-your-environment">Preparing your environment</a></h1>
<blockquote>
<p><strong>Preliminaries</strong></p>
<p>This chapter expects the reader to have a personal computer
(running a modern version of <em>Windows</em>, <em>macOS</em> or a commonly used <em>GNU/Linux</em>
distribution) to which one has root/administrator permissions. Furthermore,
especially for <em>macOS</em> and <em>GNU/Linux</em>, a basic understanding of the shell is
recommended.</p>
</blockquote>
<p>Although working with the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> requires little setup, it has some
prerequisites. Apart from from the usual text editor and <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, we need to
install some libraries and toolchains. What we need to install also depends on
what we want to achieve with this walkthrough. So the next few sections are
going to take you through some of the common necessities. Along with some of
things that could come in handy whilst following this walkthrough.</p>
<h1 id="python-and-pip"><a class="header" href="#python-and-pip">Python and Pip</a></h1>
<p>We are going to be heavily relying on <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> to do most of our measurements.
We are also going to do some data analysis using <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>. Because of this heavy
reliance on <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>, we need to install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> along with some packages for it.
Two will be manditory: <a href="https://numpy.org/">NumPy</a> and the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> library (which will be
covered in <a href="preparing/./chipwhisperer.html">ChipWhisper</a>) and two are optional but very
useful: <a href="https://matplotlib.org/">matplotlib</a> which is used for data plotting and <a href="https://github.com/tqdm/tqdm">TQDM</a> which is used
for visual feedback whilst cracking.</p>
<h2 id="installing-python"><a class="header" href="#installing-python">Installing Python</a></h2>
<p>The code provided by this walkthrough uses <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 3 and will <strong>NOT</strong> work on
<a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 2. Installing <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is a platform dependent workflow. Here are some
common operating systems, for other operating systems a simple <a href="https://letmegooglethat.com/?q=installing+python">Google
search</a> or a glance at
<a href="https://www.python.org/">Python.org</a> should do the trick.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>For <em>Windows</em>, download and run the <em>Windows installer</em> from
<a href="https://www.python.org/downloads/windows/">Python.org</a>. For most people the
64-bit version should be the one.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>For <em>macOS</em>, you can either install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> using <a href="https://brew.sh/">Homebrew</a>
with the following shell command.</p>
<pre><code class="language-bash">brew install python3
</code></pre>
<p>Or you can install <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> via the <a href="https://www.python.org/downloads/mac-osx/">macOS
Installer</a>. Depending on whether on
whether you own an Intel-based macOS device or an ARM-based macOS, you can
select the 64-bit Intel or 64-bit universal2 installer, respectively.</p>
<blockquote>
<p><em>Note:</em> <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> on <em>macOS</em> tends to give a lot of problems. There is a big
chance that <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is already installed or that only <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 2 is
installed.</p>
</blockquote>
<h3 id="gnulinux"><a class="header" href="#gnulinux">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, you can use the following commands.</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install python3 python3-pip
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, you can use the following
command.</p>
<pre><code class="language-bash">sudo pacman -S python python-pip
</code></pre>
<h3 id="validating-your-installation"><a class="header" href="#validating-your-installation">Validating your installation</a></h3>
<p>To check whether your installation was successful, restart your shell and run
the following command.</p>
<pre><code class="language-bash">python3 --version
</code></pre>
<p>For most installations, this should have also installed <code>pip</code>. We can verify
this with.</p>
<pre><code class="language-bash">pip3 help
</code></pre>
<blockquote>
<p><em>Note:</em> If <a href="https://pypi.org/project/pip/">pip</a> is not installing by default when you install Python. A
simple google search should do the trick.</p>
</blockquote>
<h2 id="numpy"><a class="header" href="#numpy">NumPy</a></h2>
<p>One of the most common packages used in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> is the <a href="https://numpy.org/">NumPy</a> package. We are
also going to be using it here to do some data transformations. To install
<a href="https://numpy.org/">NumPy</a> we can use <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">pip install numpy
</code></pre>
<h2 id="pyplot"><a class="header" href="#pyplot">PyPlot</a></h2>
<p>With our data it may be handy to plot our data. Most of the plotting done in
this walkthrough has the image attached with it, however. <a href="https://matplotlib.org/">Matplotlib</a> is
therefore recommended, but optional.  Installing is also via <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">python -m pip install -U matplotlib
</code></pre>
<h2 id="tqdm"><a class="header" href="#tqdm">TQDM</a></h2>
<p>To have a better overview of the progress our calculations are making, this
walkthrough uses the progress bars from <a href="https://github.com/tqdm/tqdm">TQDM</a>.
This is also optional, but indeed very handy. Installation can be done via <a href="https://pypi.org/project/pip/">pip</a>.</p>
<pre><code class="language-bash">pip install tqdm
</code></pre>
<h1 id="chipwhisperer-1"><a class="header" href="#chipwhisperer-1">ChipWhisperer</a></h1>
<p>The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> framework has a <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> library to interact with its
devices.  This library is definitely a necessity if you plan on doing your own
traces.</p>
<h2 id="installing-the-dependencies"><a class="header" href="#installing-the-dependencies">Installing the dependencies</a></h2>
<p>The <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python library has some dependencies. Mainly, these
dependencies are <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> and <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>. Let us go over the different operating
systems and what needs to be done there.</p>
<blockquote>
<p><em>Note:</em> If something here is not working correctly or not up to date. Refer
back to the original <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> documentation that can be found
<a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html">here</a>.</p>
</blockquote>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<p>For <em>Windows</em>, we mainly need to install <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>. There are multiple ways to do
this. I suggest installing <a href="https://letmegooglethat.com/?q=MinGW">MinGW</a> and
adding <code>MinGW\msys\1.0\bin</code> to your <code>PATH</code> environment variable.</p>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<p>For <em>macOS</em>, <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a> should already be installed. To install <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a>, we can
use <a href="https://brew.sh/">Homebrew</a>.</p>
<pre><code class="language-bash">brew install libusb
</code></pre>
<h3 id="gnulinux-1"><a class="header" href="#gnulinux-1">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, we can install both <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a> and
<a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> using the following command.</p>
<pre><code class="language-bash">sudo apt install libusb-dev make
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, we can install both <a href="https://en.wikipedia.org/wiki/Make_(software)">make</a>
and <a href="https://en.wikipedia.org/wiki/Libusb">libusb</a> using the following command.</p>
<pre><code class="language-bash">sudo pacman -S libusb make
</code></pre>
<h2 id="installing-the-python-library"><a class="header" href="#installing-the-python-library">Installing the python library</a></h2>
<p>To install the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> library, we can use <a href="https://pypi.org/project/pip/">pip</a>. We install it with the following
command.</p>
<pre><code class="language-bash">pip install chipwhisperer
</code></pre>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying installation</a></h2>
<p>To verify that the installation succeeded, we can start <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> in interactive
mode using the <code>python3</code> shell command. Then we should see something such as the
following.</p>
<pre><code class="language-text">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>We can use the following <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code to attempt to import the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>
python library.</p>
<pre><code class="language-python3">import chipwhisperer as cw
</code></pre>
<p>If there aren't any error messages, we have successfully installed the
<a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python library!</p>
<h2 id="note-for-gnulinux-users"><a class="header" href="#note-for-gnulinux-users">Note for GNU/Linux users</a></h2>
<p>When we are going to start doing traces, one might run into a missing
<strong>permissions</strong> error.  This has to do with the <code>udev</code> rules. How to solve this,
refer to the <a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#hardware-drivers">ChipWhisperer
docs</a>.
This should solve having to run everything with <code>sudo</code>, which is not preferred.</p>
<h1 id="compiling-your-own-algorithms"><a class="header" href="#compiling-your-own-algorithms">Compiling your own algorithms</a></h1>
<p>This walkthrough provides most of the precompiled code you might need. However,
in order to do some of the provided exercises and do some experimentation
yourself, you might want to compile some algorithm. To do this, there are two
things we need. The toolchain to compile to our specific microprocessor
architecture and the low-level source code to compile.</p>
<h2 id="toolchains"><a class="header" href="#toolchains">Toolchains</a></h2>
<p>In order to compile code which is usable for our specific microprocessor
architecture, we need to toolchain for that architecture. As said in the
<a href="preparing/../intro.html">introduction chapter</a>, this walkthrough is using the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite Arm</a>
variant and therefore here we will show how to install the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM toolchain</a>. For
other toolchains, have a look at the <a href="https://chipwhisperer.readthedocs.io/en/latest/prerequisites.html#compilers">ChipWhisperer
documentation</a>.</p>
<h2 id="installing-the-arm-toolchain"><a class="header" href="#installing-the-arm-toolchain">Installing the ARM toolchain</a></h2>
<p>Information on the ARM can be found
<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">here</a>.</p>
<h3 id="windows-and-macos"><a class="header" href="#windows-and-macos">Windows and macOS</a></h3>
<p>por <em>Windows</em> and <em>macOS</em>, the installer on the <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">ARM developer
website</a>
should be enough to install the ARM embedded toolchain.</p>
<h3 id="gnulinux-2"><a class="header" href="#gnulinux-2">GNU/Linux</a></h3>
<p>For <a href="https://en.wikipedia.org/wiki/Debian">Debian</a> based systems, including <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>, we can use the following command
to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo apt install gcc-arm-none-eabi
</code></pre>
<p>For <a href="https://en.wikipedia.org/wiki/Arch_Linux">ArchLinux</a> based systems, including <a href="https://en.wikipedia.org/wiki/Manjaro">Manjaro</a>, we can use the following
command to install the ARM embedded toolchain.</p>
<pre><code class="language-bash">sudo pacman -S arm-none-eabi-gcc
</code></pre>
<h2 id="compiling-binaries"><a class="header" href="#compiling-binaries">Compiling binaries</a></h2>
<p>With the proper toolchain installed, we can compile binaries which are going to
used on the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> <em>targets</em>. Take a look at <a href="https://github.com/coastalwhite/simpleserial-c-template">Simpleserial C Template</a>.
It explains how to create and compile your own binaries. Or have a look at <a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware">the
ChipWhisperer GitHub
repository</a>
for some examples of prewritten algorithms.</p>
<blockquote>
<p><em>Note:</em> <a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">SimpleSerial</a> is the protocol <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> utilizes to describe p
communicating between the host machine (e.g. a laptop), through the <em>scope</em>,
and the <em>target</em>. Some documentation on the <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">C</a> library on it can be found
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial">here</a>.</p>
</blockquote>
<h1 id="a-case-study-rsa"><a class="header" href="#a-case-study-rsa">A case study: RSA</a></h1>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is an encryption algorithm that is used all over the place. That little
padlock in your browser; it is powered by <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>. Coding an implementation of
<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is reasonably simple, but the mathematics behind it can prove to be really
though. Luckily, there is no need to dive too much into the mathematics to crack
<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> using <a href="https://en.wikipedia.org/wiki/Power_analysis#Simple_power_analysis">Simple Power analysis</a>. In the chapter on <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, we will go a bit
deeper into cache-based <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> attacks, why they work exactly and how
to perform them on the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>. This chapter is going to skip over a few
of the specifics to create a better overview of our method and goals.</p>
<h2 id="what-is-rsa"><a class="header" href="#what-is-rsa">What is RSA?</a></h2>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is an algorithm used to do <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">asymmetric
encryption</a>. This means
we have two distinct keys. Most of the time this means we have one key to
encrypt plain text to cipher text, one key to decrypt cipher text back to plain
text. It is common to have one of these keys be publicly available while the
other is kept extremely private. Because of this, it is also called the public
and private key cryptography.</p>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> uses one simple principle. For encryption with public key \( e \), for
every byte of our plain text \(b_i\) we have encrypted byte \( c_i=b_i^e \)
modulo some integer \( N \). For decryption with private key \( d \), for
every byte of our cipher text \(c_i\) we have encrypted byte \( b_i=c_i^d \)
modulo some integer \( N \). The specific relationship between these numbers is not as
important for now.</p>
<p>When one learns that usually the minimum key length for the private key is <em>1024
bits</em>, one might wonder how these computations are actually done on the bare
hardware. It turns out that we can interpret modulo taking a of power as
repeated multiplication and squaring alternated with modulo division. This is
how that works.</p>
<p>If we are given a enormous number \( x \) and we are tasked with the raising
it to the 13th power, we might do it as follows:</p>
<p>\[ x^{13} = x^8 \cdot x^4 \cdot x^1 \]</p>
<p>This is part of the method of <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">Modular
Exponentiation</a>. Notice
that \((13)_{10} = (1101)_2\). There are some ties with powers of 2 here.
Thus, we might write a custom power function in <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> as the following.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y)
def custom_pow(x, y):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x

    return res
</code></pre>
<p>If we add a modulo into our function, we have essentially created a function to
do RSA encryption. This is also often how the pseudocode for lower level
implementation looks like.</p>
<pre><code class="language-python"># Custom implementation of pow(x, y) % p
# With p &gt;= 2
def custom_pow_mod(x, y, p):
    res = 1

    # Until we have reached the highest power
    while (y &gt; 0):
        # If the last byte is a one
        if (y &amp; 0x01):
            res *= x
            res %= p # Make sure we stay modulo p

        # Move on to the next byte
        y &gt;&gt;= 1
        x *= x
        x %= p # Make sure we stay modulo p

    return res
</code></pre>
<blockquote>
<p><em>Note:</em> This is in fact also how most arbitrary precision library implement
raising to the power. This is due the (relatively) low maximum complexity of
this calculation.</p>
</blockquote>
<p>If you are already a small bit familiar with <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel Analysis</a> and <a href="https://en.wikipedia.org/wiki/Power_analysis">Power
Analysis</a>, you might immediately see what is going wrong here. If you don't see
it immediately, let us go through it together.</p>
<p>When we do <a href="https://en.wikipedia.org/wiki/Power_analysis">Power Analysis</a>, we get the power consumption of a microprocessor
for a given amount of time. Let us say we would we have a computer purely
executing the computation for <code>custom_pow_mod(3, 5, 15)</code>. The steps that are
taken in this computation are done noted below. Take a look at that the
computation and verify it in your head.</p>
<pre><code class="language-python">custom_pow_mod(3, 5, 15):

res := 1

# Round 1

# [A]
y &gt; 0 = 5 &gt; 0 is true, thus:
    y &amp; 0x01 = 5 &amp; 0x01 is 1, which equals true, thus:
        # [B]
        res := res * x = 1 * 5 = 5
        res := res % 15 = 5 % 15 = 5

    # [C]
    y := y &gt;&gt; 1 = 5 &gt;&gt; 1 = 2
    x := x * x = 3 * 3 = 9
    x := x % 15 = 9 % 15 = 9


# Round 2

# [D]
y &gt; 0 = 2 &gt; 0 is true, thus:
    y &amp; 0x01 = 2 &amp; 0x01 is 0, which equals false

    # [E]
    y := y &gt;&gt; 1 = 2 &gt;&gt; 1 = 1
    x := x * x = 9 * 9 = 81
    x := x % 15 = 81 % 15 = 6

# Round 3

# [F]
y &gt; 0 = 1 &gt; 0 is true, thus:
    y &amp; 0x01 = 1 &amp; 0x01 is 1, which equals true, thus:
        # [G]
        res := res * x = 5 * 6 = 30
        res := res % 15 = 30 % 15 = 0

    # [H]
    y := y &gt;&gt; 1 = 1 &gt;&gt; 1 = 0
    x := x * x = 6 * 6 = 36
    x := x % 15 = 36 % 15 = 6

# Round 4

# [I]
y &gt; 0 = 0 &gt; 0 is false.

# [J]
Result: 0
</code></pre>
<p>One might notice that not every round contains the same amount of steps, and
thus, we might imagine that the power consumption of our machine looks similar
to <em>Figure 1</em>.</p>
<p><img src="../assets/estimate-power-consumption-rsa.jpg" alt="Estimate of RSA power consumption" /></p>
<p><em>Figure 1: A projected power trace for the</em> <code>custom_pow_mod(3, 5, 15)</code> <em>function
call.</em></p>
<blockquote>
<p><em>Note:</em> This sketch uses the estimate that conditionals and loops (<code>if</code> and
<code>while</code>) are less power consuming than normal numerical calculations (<code>&gt;&gt;</code>,
<code>*</code> and <code>%</code>), which isn't trivially true, but for the sake of
simplicity we are going to assume it is true.</p>
</blockquote>
<p>You might notice that given this sketch, we can reconstruct some information
about the argument <code>y</code> provided to the <code>custom_pow_mod</code> function. We start with
a long spike, thus, the binary number representation of <code>y</code> starts with a <code>1</code>.
This is followed by a short spike, which indicates a <code>0</code>. And lastly, we see a
long spike again. Therefore, we end with an <code>1</code>. And we get the binary number
<code>101</code> for our <code>y</code>. This equals 5 in decimal, which is correct.</p>
<p>Let us do another one, now without knowing the answer before hand. Take a look
at <em>Figure 2</em>.</p>
<p><img src="../assets/rsa-key-42.jpg" alt="RSA key 42" /></p>
<p><em>Figure 2: A projected power trace for the</em> <code>custom_pow_mod</code> <em>function.</em></p>
<p>We start with two short spikes, and thus we start with two zeros. Then we
alternate a long spike with a short spike three times. This means we get
<code>00101010</code>. This is equal to decimal 42. And thus the <code>y</code> we started with is 42.</p>
<h2 id="what-does-this-tell-us"><a class="header" href="#what-does-this-tell-us">What does this tell us?</a></h2>
<p>The previous code example may seem cherry picked. In fact, it is not. This code
snippet does, however, indicate the concept of <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a> very nicely and
is therefore an extremely good visual example of how to break a <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>
implementation. Code following the same principle or even this exact algorithm
is extremely common. This means that whilst this exact method may not be
applicable everywhere, the underlying idea still is.</p>
<p>So whilst this method specifically is interesting, we are more interested in
whether looking into an algorithm can tell us something about data used from the
patterns in a power trace. In the next chapter, we are going to have go through
how this can be done with <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>.</p>
<h1 id="breaking-aes"><a class="header" href="#breaking-aes">Breaking AES</a></h1>
<p><a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> or the <em>Advanced Encryption Standard</em>, is one of the most used
symmetric encryption algorithms in today's world. It is used for most encrypted
conversations between computers or applications. It is used by your chat apps
and by your password manager. <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> has the advantage of being relatively fast and
easy to understand.</p>
<p>Since <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> is very widely used, any found vulnerability should be taken extremely
serious. It is widely considered that <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> is mathematically secure and
therefore <em>perfect implementations</em> of the algorithms should not be vulnerable to
most standard attacks. You may see a caveat here:</p>
<p><strong>Have we created perfect implementations of the AES algorithm?</strong></p>
<p>Although there are some <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> implementations that have existed for over 2
decades<sup class="footnote-reference"><a href="#openssl">1</a></sup>. There are still regular updates to these libraries, because
from time to time people find new mistakes in the implementation of these
algorithms. Code is messy, people make mistakes or are ignorant. <a href="https://en.wikipedia.org/wiki/Side-channel_attack">Side-Channel
analysis</a> is a attack-vector that is often overlooked or ignored since it
requires physical access to the device.</p>
<p>In this section we will have a look at how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works, cracking a naive
implementation of the algorithm and see how <a href="https://en.wikipedia.org/wiki/Power_analysis">Power Analysis</a> can be used to
expose the key used.</p>
<div class="footnote-definition" id="openssl"><sup class="footnote-definition-label">1</sup>
<p>OpenSSL has been copyrighted since 1999 — <a href="https://www.openssl.org/">https://www.openssl.org/</a></p>
</div>
<h1 id="how-aes-works"><a class="header" href="#how-aes-works">How AES Works</a></h1>
<p>In order to do break <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> with power analysis, we need a reasonably detailed
understanding of how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works. So let us do a crash course.</p>
<p>The <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm is a subset of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a> algorithm and
has basically become synonymous with it. As the name <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>
implies, we apply the encryption to fixed-size blocks of plain text. With the
size of the blocks being equal to the key size. The encryption is based on
alternating <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations and shuffling the bytes of the blocks. Let dive
into each individual component of the algorithm.</p>
<h2 id="the-plan"><a class="header" href="#the-plan">The Plan</a></h2>
<p>As said previously, the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm works by alternating <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations
with the shuffling of the bytes of the blocks. The algorithm specifies that this
is done in rounds. Since <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> has 3 different key sizes (128, 192 and 256
bits), each different key size also has a different number of rounds. The amount
of rounds are 10, 12, and 14, respectively.</p>
<p>How does a round look like? Although the first round and the last round have
small differences to the rest we can divide all the rounds up into two sections the
shuffling of bytes and the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation. Let us first have a look at the
<a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operations.</p>
<h2 id="xor-operations"><a class="header" href="#xor-operations">XOR operations</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation is essentially the mixing in of the key and is what makes the
running of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm different depending on what key is used. Firstly,
in order to make reversal even more different, we <strong>create multiple new keys from
the original key</strong>. This is called the
<a href="https://en.wikipedia.org/wiki/AES_key_schedule">AES key schedule</a>. This
walkthrough will not go into detail on how this key-expansion works, but if
interested one can look up details. The part which is important to this walkthrough
is that after this expansion we have as many new keys as we have rounds. We will
number all the from \(k_0\) to \(k_{10}\) (assuming we are using 128 bit <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>).
Here \(k_0\) is the original key and \(k_1\) till \(k_{10}\) are
the expanded keys.</p>
<p><img src="aes/../assets/AES_Key_Schedule.svg" alt="AES Key Schedule" /></p>
<p><em>Figure 1: The AES Key Schedule</em></p>
<p>With these keys we performs a <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> on a block. The <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation is a
notorious one way operation. This is due to the lack of information the output
shares about the input. When we do a one bit <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation and we receive 1 as
an output, the input could have been (0,1) or (1,0). We also have two options
when we get 0 as output. In the case of one bit, this is not that useful.
However, when we a lot of bits the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operator is impossible to instantly
reverse for every output and brute forcing time is equal to trying every option
divided by two. Mathematically this caused by the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation being
non-<a href="https://en.wikipedia.org/wiki/Injective_function">injective</a>. When we have
the outcome and one of the inputs however, this step is extremely easy to
reverse. These two properties make it ideal for a lot of encryption algorithms.</p>
<p><img src="aes/../assets/XOR_NonInjectivity.svg" alt="XOR Non Injective" /></p>
<p><em>Figure 2: The non <a href="https://en.wikipedia.org/wiki/Injective_function">injective</a> nature of the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> operation</em></p>
<h2 id="shuffling-of-bytes"><a class="header" href="#shuffling-of-bytes">Shuffling of bytes</a></h2>
<p>Next let us have a look at the other parts of each round. The shuffling of
the block bytes. <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>s have 3 distinct shuffling techniques:
<strong>substitution, shifting, and mixing</strong>. We are going to have a look at all three
of these shuffling techniques, but let us first have a look at how <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael
block cipher</a>s view each block.</p>
<h3 id="block-of-blocks"><a class="header" href="#block-of-blocks">Block-of-blocks?</a></h3>
<p>Rijndael looks at blocks as a matrix of bytes. For the key sizes of key sizes of
128, 192 and 256 bits, we have 4 by 4, 6 by 6 and 8 by 8 matrices, respectively.
This would mean that a 128 bit key with bytes \(b_0, ..., b_{15}\) is turned
into \[
\begin{bmatrix}
b_0 &amp; b_4 &amp; b_8 &amp; b_{12} \\
b_1 &amp; b_5 &amp; b_9 &amp; b_{13} \\
b_2 &amp; b_6 &amp; b_{10} &amp; b_{14} \\
b_3 &amp; b_7 &amp; b_{11} &amp; b_{15}
\end{bmatrix}
\]
Turning a long string of bytes into a matrix allows for matrix operations, which
are common operations for computers. This provides both clarity and speed.</p>
<h3 id="substitution"><a class="header" href="#substitution">Substitution</a></h3>
<p>Now comes one of the most genius but strange parts of the Rijndael block
cipher. This is the substitution box. A substitution box is basically a lookup
table to replace (or substitute) a byte with the one from the lookup table. Some
demands for such a lookup table (when used in encryption algorithms) may be:</p>
<ul>
<li><strong>Reverseable</strong>: In order to find back the original byte, we want to be able
to reverse the process.</li>
<li><strong>Non-Linear</strong>: In order to make resistant to
<a href="https://en.wikipedia.org/wiki/Linear_cryptanalysis">linear</a> and
<a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis">differential</a>
cryptanalysis, the lookup should be very difficult to approximate with a
linear function.</li>
<li><strong>Fixed Output Sizing</strong>: In order to reduce the complexity and loss of excess
data, we want to output to have a fixed bit size (preferably the same as the
input).</li>
</ul>
<p>The <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-Box</a> does all these things. Since it has all of these
properties, how it specifically looks is not important. Every implementation of
<a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> can save the Substitution-Box and its inverse in static memory since it is
public knowledge.</p>
<p>Here is the <a href="https://en.wikipedia.org/wiki/Rijndael_S-box">Rijndael S-Box</a> as a <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> array.</p>
<pre><code class="language-python"># Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]
</code></pre>
<h3 id="shifting"><a class="header" href="#shifting">Shifting</a></h3>
<p>The most plain, but equally important, round step is the shifting of the rows.
This step prevents the columns (4 consecutive bytes in the case of the 128 bit
variant) from being <strong>encrypted and decrypted separately</strong>. The step consists of
shifting the first row of the matrix by zero, the second by one, the third by
two and the fourth by three spaces. This is depicted in <em>Figure 3</em>.</p>
<p><img src="aes/../assets/Shift_Rows.svg" alt="Shift Rows" /></p>
<p><em>Figure 3: <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael block cipher</a>'s Shift Row</em></p>
<h3 id="mixing"><a class="header" href="#mixing">Mixing</a></h3>
<p>The last shuffling step mixes the columns in order create <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">cryptographic
diffusion</a>, which makes
it <strong>resistant to <a href="https://en.wikipedia.org/wiki/Frequency_analysis">statistical analysis
attacks</a></strong>. The step works by
multiplying each column with the following inversable matrix (multiplication
meaning modulo multiplication and addition meaning <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a>): \[ \begin{bmatrix} 2
&amp; 3 &amp; 1 &amp; 1 \\ 1 &amp; 2 &amp; 3 &amp; 1 \\ 1 &amp; 1 &amp; 2 &amp; 3 \\ 3 &amp; 1 &amp; 1 &amp; 2
\end{bmatrix} \]</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Let us now provide a overview for how a typical <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> encryption looks. One can
imagine that the decryption is just the inverse of these actions we will
therefore gloss over that part.</p>
<p>As said before, the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> encryption process works in rounds. With every round
needing a separate expanded key. Therefore the first step is to create these key
expansions as described in <a href="aes/workings.html#xor-operations">XOR Operations</a>. Immediately
following this we that the initial round key \(k_0\) and apply the <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> with
it to each block.</p>
<p>After the summation with the initial round key we will start applying rounds (9,
11 and 13 rounds for key sizes 128, 192 and 256 bits, respectively). These
rounds apply steps in the following order: Firstly, we do a <a href="aes/workings.html#substitution">substitution with the
Rijndael S-Box</a>. Secondly, we <a href="aes/workings.html#shifting">shift the rows of the
matrix</a>. Thirdly, we <a href="aes/workings.html#mixing">mix the columns of the matrix up</a>.
Lastly, we <a href="aes/workings.html#xor-operations">add the round key for that round</a>.</p>
<p>If you are counting along, you will notice that the final round is missing. This
is because the final round is a little bit different. The only difference being
that we <strong>skip the <a href="aes/workings.html#mixing">mixing of
columns</a></strong> step, since it serves no purpose in last round.</p>
<p>This all results in the following process:</p>
<ol>
<li><a href="aes/workings.html#xor-operations">Key Expansion</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_0\) by XOR</a></li>
<li>Apply 9, 11, or 13 rounds
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#mixing">Mix the columns</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by XOR with \(n\) being the round
number</a></li>
</ol>
</li>
<li>Final round
<ol>
<li><a href="aes/workings.html#substitution">Substitution with the Rijndael S-Box</a></li>
<li><a href="aes/workings.html#shifting">Shift the rows</a></li>
<li><a href="aes/workings.html#xor-operations">Apply \(k_n\) by XOR with \(n\) being the round
number</a></li>
</ol>
</li>
</ol>
<p>After reading this section should have a basic overview and understanding of how
<a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> works, which you will need for your <a href="https://en.wikipedia.org/wiki/Power_analysis">Power analysis</a>. If you want a more
visual explanation, you could watch <a href="https://www.youtube.com/watch?v=O4xNJsjtN6E">AES Explained by
Computerphile</a>.</p>
<h1 id="capturing-multiple-traces"><a class="header" href="#capturing-multiple-traces">Capturing multiple traces</a></h1>
<p><a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> is a lot more complex than <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>. Although looking at one trace of <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>
can give you a lot of information about the key used, with <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> it is a lot
more common to take multiple traces and average them out. Here we are gonna have
a look at how we can upload the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> source code to the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> target
board, and then capture multiple power traces.</p>
<h2 id="base-setup"><a class="header" href="#base-setup">Base setup</a></h2>
<p>Assuming that you have correctly <a href="aes/../preparing.html">setup your environment</a>, we
first have to connect to the <em>scope</em> and the <em>target</em>. The scope being the
measuring device and the target being the microprocessor, which is going to run
the encryption algorithm. In order to connect to the scope and the target, we
need the following code.</p>
<pre><code class="language-python">import chipwhisperer as cw

# Setup a connection with the CW board
# and fetch the scope for using this board.
scope = cw.scope()

# The default settings are fine for now.
scope.default_setup()

# Fetch the target from the scope
# This should be automatically connected
target = cw.target(scope)
</code></pre>
<p>In order to disconnect them again, we can use the following code.</p>
<pre><code class="language-python">scope.dis()
target.dis()
</code></pre>
<h2 id="flashing-the-source-code"><a class="header" href="#flashing-the-source-code">Flashing the source code</a></h2>
<p>Depending on what target we are using, we need different software. We can
compile this ourselves, but most compiled code can also be found online. The
compiled code for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> can be found
<a href="https://github.com/newaetech/chipwhisperer/tree/develop/hardware/victims/firmware/simpleserial-aes">here</a>.</p>
<p>We always have the flash the source code onto the <a href="https://www.newae.com/products/NAE-CWLITE-ARM">CW Lite ARM</a> using the <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel
Hex format</a>. Therefore, assuming we are
using the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> Lite 32-bit ARM-edition, we can the <code>CWLITEARM</code> hex file.
in order to upload the program to the target, we can use the following <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>
code.</p>
<pre><code class="language-python">from chipwhisperer.capture.api.programmers import STM32FProgrammer
import os

# Initiate a new STM32F Program
# STM32 being the ARM microcontroller that we are using
# https://en.wikipedia.org/wiki/STM32#STM32_F3
program = STM32FProgrammer

# Get the path to the current folder
# Adjust accordingly
aes_firmware_dir = os.path.dirname(os.path.realpath(__file__))
aes_hex_path = os.path.join(aes_firmware_dir, r&quot;hexfiles/simpleserial-aes-CWLITEARM.hex&quot;)

# Apply the program to the actual target
# This allows us to run the hex code on the microcontroller
cw.program_target(scope, program, aes_hex_path)
</code></pre>
<h2 id="capturing-a-trace"><a class="header" href="#capturing-a-trace">Capturing a trace</a></h2>
<p>In order to run our first trace, we need a key and some plain text. The program
we are using is based on <em>128 bit AES</em> and therefore we should provide a
128 bit key and a multiple or 128 bits for our plain text. We can quite easily
create our first trace, with the following code.</p>
<pre><code class="language-python"># Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'H4ck3rm4n-l33t42'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the plain text used
# This plain text has to be a multiple of
# 128 bits = 16 bytes = 16 ascii characters in length.
plain_text = bytearray('a' * 16, 'ascii')

# Capture the actual trace
trace = cw.capture_trace(scope, target, plain_text, key)
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Within the <a href="https://chipwhisperer.readthedocs.io/en/latest/simpleserial.html">SimpleSerial</a> protocol — which is used under the
hood by the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> devices — the
<a href="https://chipwhisperer.readthedocs.io/en/latest/api.html?highlight=capture_trace#chipwhisperer.capture_trace"><code>capture_trace</code></a>
function corresponds with a couple of steps (arming the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a>,
sending the key/plaintext and retrieving the trace data, etc.). This can
become important when implementing your own algorithms. There it may be
important to replace w this one function with its individual steps to get more
control over the commands send. This can be seen in the <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> code of the
<a href="https://github.com/coastalwhite/simpleserial-c-template">SimpleSerial C
template</a>.</p>
</blockquote>
<p>This is very interesting, but we don't really have any confirmation or
visualization. So let us visualize it with <a href="https://matplotlib.org/">matplotlib</a>.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(trace.wave)
plt.show()
</code></pre>
<p>This should look something like <em>Figure 1</em>.</p>
<p><img src="aes/../assets/aes_single_trace_plot.png" alt="AES Single Power Trace" /></p>
<p><em>Figure 1: <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> Single Power Trace</em></p>
<h2 id="capturing-more-than-one-trace"><a class="header" href="#capturing-more-than-one-trace">Capturing more than one trace</a></h2>
<p>We can turn this into multiple traces with a simple <code>for</code> loop. Here we are
going to be using the <a href="https://github.com/tqdm/tqdm">TQDM</a> library to have a nice progress bar. So let us
create 100 traces with random input text and save all relevant data into a
<a href="https://numpy.org/">numpy</a> arrays.  This way we can save the eventual traces and plain texts to a
file.</p>
<p>First we define a function for creating random plain text strings.</p>
<pre><code class="language-python">import string
import random

def random_string(length):
    # Define the alphabet of the random string
    # Here we take the lowercase latin alphabet in ascii encoding
    # e.g. &quot;cpjsapcnrsdtjvlo&quot;, &quot;btqfocsprbualtwt&quot; or &quot;yzkwewjbkpmriccx&quot;
    alphabet = string.ascii_lowercase

    # Return a string with the given length with randomly chosen chars
    return ''.join(random.choice(alphabet) for i in range(length))
</code></pre>
<p>Then we capture some traces.</p>
<pre><code class="language-python">from tqdm import trange

# Define the key used for the encryption
# This key has to be 128 bits = 16 bytes
# = 16 ascii characters in length
key_str = 'H4ck3rm4n-l33t42'

# Convert the key to a byte array
key = bytearray(key_str, 'ascii')

# Define the constant for the amount of traces
N = 5

textins = []
traces = []

# Loop through all traces
for i in trange(N, desc=&quot;Capturing traces&quot;):

    # Define the plain text used
    # This plain text has to be a multiple of
    # 128 bits = 16 bytes = 16 ascii characters in length.
    plain_text = bytearray(random_string(16), 'ascii')

    # Capture the actual trace
    trace = cw.capture_trace(scope, target, plain_text, key)

    # If the capture timed out move to the next capture
    if trace is None:
        continue

    textins.append(plain_text)
    traces.append(trace.wave)
</code></pre>
<p>Then we turn this into numpy arrays.</p>
<pre><code class="language-python">np_traces = np.asarray(traces)
np_textins = np.asarray(textins)
</code></pre>
<p>Then we can save it to a file.</p>
<pre><code class="language-python">np.save('output/traces.npy', np_traces)
np.save('output/textins.npy', np_textins)
</code></pre>
<p>This way we can later load it.</p>
<blockquote>
<p>For more information on how to do scripting with the <a href="https://github.com/newaetech/chipwhisperer">ChipWhisperer</a> python
module have a look over <a href="https://wiki.newae.com/Making_Scripts">here</a>.
<strong>Disclaimer:</strong> This is quite heavy.</p>
</blockquote>
<h1 id="modeling-aes"><a class="header" href="#modeling-aes">Modeling AES</a></h1>
<p>In order to make sensible statements about the power usage of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, it can be
handy to make a model of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm. To do this, we need some
understanding about how computers use power and how the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> algorithm
functions. The first of which we will discuss here and the second is discussed
in the chapter <a href="aes/./workings.html">How AES Works</a>.</p>
<h2 id="hamming-distance-and-hamming-weight"><a class="header" href="#hamming-distance-and-hamming-weight">Hamming Distance and Hamming Weight</a></h2>
<p>Remember that computers are just emergent properties that we get when we have a
ton of <a href="https://en.wikipedia.org/wiki/Transistor">transistors</a>,
<a href="https://en.wikipedia.org/wiki/Capacitor">capacitors</a>, wires, etc. in the
correct setup. This means that if we look at the capacitors level, there should
be some capacitors that represents the state of a bit. Here mainly our interest
falls on the internal state of memory. Since, we know that capacitors represents
a binary 1 with a certain amount of charge and a binary 0 with close to no
charge. We can ask ourselves the question, does it cost more power to set or
maintain memory which involves more binary 1's than 0's. In fact, it indeed
does. This gives us two models for looking at the power usage of memory.
<strong>Looking at how much power it would take to set memory, which is known as the
Hamming Distance model. Or we can look at how much power it would take to
maintain memory, which is known as the Hamming Weight model.</strong> Hamming Distance
meaning the amount of bitflips needed to turn one memory state into another, and
Hamming Distance meaning the amount of 1's in a certain memory state.</p>
<p>We can easily create a python function, which would identify the Hamming weight
or Hamming distance.</p>
<pre><code class="language-python"># Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)
</code></pre>
<p>Although it can be worth it to save this to memory, to speed to computation time
later on.</p>
<pre><code class="language-python"># ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]
</code></pre>
<p>Although both models work for power usage, mainly to avoid repetition, from
<strong>here on out we will be using the Hamming Weight model</strong>.</p>
<h2 id="making-a-statement-about-aess-memory-state"><a class="header" href="#making-a-statement-about-aess-memory-state">Making a statement about AES's memory state</a></h2>
<p>Suppose we have an input block \(Input\) and an output block \(Output\),
which is a reasonably common situation. If we would want to check whether a
supposed \(Key\) is the key used, we could run through the entire algorithm to
check whether \(\text{AES}(Input, Key) = Output\). This is quite inefficient
and is no better than brute forcing the key. Knowing what we now about the
memory state of <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> we can however do two extreme optimizations.</p>
<h3 id="shortcutting-calculations"><a class="header" href="#shortcutting-calculations">Shortcutting calculations</a></h3>
<p>The first optimization we can do has to do with identifying the first memory state
where the key and the \(Input\) are combined. If we can identify this memory
state in the power trace, we can determine a probability a certain key was used.
There are two problems with this however. Firstly, identifying the presence or
the location of this memory state is non-trivial. It is very difficult to
manually look at a power trace and tell something about memory states. This is
is mostly due to the variances in baseline power consumption but also due to
noise and other factors. Some of these factors however can be nullified if we
look at multiple power traces instead of one. In order to make it even easier,
we also also look at different input blocks. This allows us to shortcut
calculation time by a lot, since we don't have to do multiple rounds. But we
still have to brute force through every key option.</p>
<h3 id="limiting-the-amount-of-keys"><a class="header" href="#limiting-the-amount-of-keys">Limiting the amount of keys</a></h3>
<p>If we have done the first optimization, there is another optimization which
would lower the amount of possible keys. For the 128 (\(2^{128}\) different
keys), 192 (\(2^{192}\) different keys) and 256 (\(2^{256}\) different keys)
bits key variants, this leaves just \(2^{12}\), \((3 \cdot 2^{11})\) and
\(2^{13}\) key possibilities left, respectively. These are massive
differences, which will allow us to break <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> in just a few seconds.</p>
<p>How does it work? Please read back <a href="aes/./workings.html#shifting">How AES Works -
Shifting</a> for one second and see if you find what we can
exploit, when have a value before this step happens. As it mentions this, step
is needed to prevent <strong>attacking each column individually</strong>. Since we can now
produce a value before this step is done. We can attempt to break parts of the
key one at the time. The parts of this key are called sub-keys and they are 1
byte in size. This means we can take sum of different values for the sub-keys
instead of the product.</p>
<h2 id="putting-this-together"><a class="header" href="#putting-this-together">Putting this together</a></h2>
<p>Let us make a model of the memory states power usage. This model should provide
us with a number that should <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlate</a> with the power traces at the point of
which this first <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> step is done.</p>
<pre><code class="language-python">def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<h1 id="manual-analysis"><a class="header" href="#manual-analysis">Manual Analysis</a></h1>
<p>With the power usage model we described in the previous chapter, we can now
start to do some analysis of our power traces.</p>
<p>Let look what we have up until now.</p>
<pre><code class="language-python"># Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)

# ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
</code></pre>
<p>In order to load the data we created with our trace we can add the follow few
lines which will load in the <a href="https://numpy.org/">numpy</a> arrays.</p>
<pre><code class="language-python">import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

</code></pre>
<h2 id="are-we-data-scientists-yet"><a class="header" href="#are-we-data-scientists-yet">Are we data-scientists yet?</a></h2>
<p>We want to change the data in such a way that it makes it easier to identify
whether a our <strong>modeled power usage is similar to the actual power usage</strong>. We
need multiple power traces for this. The most important processing of data is
going to be using <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation coefficient</a>s.</p>
<h3 id="pearson-correlation-coefficient"><a class="header" href="#pearson-correlation-coefficient">Pearson correlation coefficient</a></h3>
<p>We have an difficult task here. Again, we want to know how likely it is that our
modeled power usage has a similar pattern to the actual power usage. In
statistics this is known as the modeled power usage and the actual power usage
having a high <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>. If two functions are in perfect correlation,
one function should always rise when the other rises and one function
should always decline when the other declines.</p>
<p>This is what the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation coefficient</a> indicates. We provide it with
two functions or arrays and it will give us a value between \(-1\) and
\(1\), indicating whether the two functions <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlate</a>. \(1\) meaning
extreme but almost unrealistic levels of <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>, \(0\) meaning no
<a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> and \(-1\) meaning a inverse <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a>. How the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson
correlation coefficient</a> manages to do this is not as important for us, but
reading the Wikipedia page can be very interesting. What is important for us is
the formula so we can use it in our code.</p>
<p>\[
\rho_{X,Y} = \frac{\text{cov}(X,Y)}{\sigma_X \sigma_Y}
\]</p>
<p>This may not be entirely clear to most people without knowledge of
statistics. So let us break it down.</p>
<ul>
<li>\(\rho\) is the letter commonly used to represent the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson correlation
coefficient</a>.</li>
<li>\(X\) and \(Y\) are our functions and can actually be represented as a
finite list of numbers in our case. This means \(X = { x_0, \ldots, x_n }\) and
\(Y = { y_0, \ldots, y_n }\) with \(n\) being an integers greater or
equal to zero.</li>
<li>\(\text{cov}(X,Y)\) is the <a href="https://en.wikipedia.org/wiki/Covariance">covariance</a> of \(X\) and \(Y\). This can be
calculated with \(\text{cov}(X,Y)=\mathbb{E}[(X - \mu_X)(Y - \mu_Y)] =
\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)(y_i - \mu_Y) \), with
\(\mu_X\) and \(\mu_Y\) being the <a href="https://en.wikipedia.org/wiki/Mean">mean</a> of \(X\) and \(Y\),
respectively.</li>
<li>\(\sigma_X\) and \(\sigma_Y\) being the <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of \(X\) and
\(Y\), respectively. The <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> can be calculated with
\(\sigma_X = \sqrt{\frac{1}{n} \sum_{i=0}^n (x_i - \mu_X)^2}\) with
\(\mu_X\) being the <a href="https://en.wikipedia.org/wiki/Mean">mean</a> of \(X\).</li>
</ul>
<p>Let us move these formulas to <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>.</p>
<pre><code class="language-python">def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
</code></pre>
<p>Although this code is very inefficient, and does a lot of unnecessary and double
calculations, it will serve well for now. We are going to be optimizing this
code in <a href="aes/./optimization.html">Sidenote: optimizing our algorithm</a>.</p>
<h3 id="cracking-a-single-byte"><a class="header" href="#cracking-a-single-byte">Cracking a single byte</a></h3>
<p>As explained in <a href="aes/./modeling.html">Modeling AES</a>, we can — using <a href="https://en.wikipedia.org/wiki/Power_analysis">power analysis</a> —
<strong>crack the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> key byte by byte</strong>. So let us start with a single one. We are
going to go through every possibility and see which byte one provides the
highest <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a> between the actual power trace and our modeled
power usage. The important realization here is that we are doing a correlation
between all individual power trace points and the hypothetical power consumption
and we will select the maximum correlation coefficient for all sub-key guesses.
This is because we still have no idea where within the power trace the first
round actually takes place. If we look at all points of each power trace, the
location where the first round takes place should have the highest correlation.
We will demonstrate this later on.</p>
<pre><code class="language-python">from tqdm import trange

def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation

# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
</code></pre>
<p>This will determine the maximum [correlation coefficients] for all sub-key guesses.
If we plot this we get the following graph.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
</code></pre>
<p><img src="aes/../assets/aes_max_correlation_coefficients.png" alt="Maximum Correlation Coefficients AES" /></p>
<p><em>Figure 1: The <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> Correlation Coefficients for the first sub-key values</em></p>
<p>Remember I used the key <code>H4ck3rm4n-l33t42</code>, where <code>H</code> or ASCII 72 is the first
sub-key byte. If you used a different key, your plot will most probably look
different and there will be a high spike at the ASCII value of your first
sub-key.</p>
<p>Well done! We have cracked our first sub-key!</p>
<h1 id="pearson-correlation"><a class="header" href="#pearson-correlation">Pearson correlation</a></h1>
<p>You might ask yourself, how did it do that? It looks a bit magical with all
these correlations. So let us try to visualize what is actually happening.</p>
<p>We are calculating all the [correlation coefficients] for all the points within
all traces. So let us compare the result of this calculation between the correct
and a wrong sub-key. Again, for me the first sub-key is <code>H</code> (ASCII 72 or hex
<code>0x48</code>). If you chose a different key, you should adjust this in the following
code.</p>
<pre><code class="language-python">plt.plot(
    abs(calculate_correlation_coefficients(0x48, 0)),
    label='correct'
)
plt.plot(
    abs(calculate_correlation_coefficients(0x00, 0)),
    label='wrong'
)

plt.legend()
plt.show()
</code></pre>
<p>This will show the following graph.</p>
<p><img src="aes/../assets/aes_correlation_visualization.png" alt="AES Pearson Correlation Explaination" /></p>
<p><em>Figure 1: A visualization of <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson Correlation Coefficient</a> for <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a></em></p>
<p>So what does this graph show? This has the <a href="https://en.wikipedia.org/wiki/Correlation_and_dependence">correlation</a> between our modeling
power consumption on the <em>y-axis</em> and the different power traces on the <em>x-axis</em>.
You can see that correlation coefficient remains reasonably consistent for the
wrong sub-key. It never goes above \(\sim 0.4\). The correct follows the same
pattern — never really reaching above \(\sim 0.4\) — except for one or two
spikes. At these spikes apparently our model matches the actual power
consumption very closely.</p>
<p>These spikes are what we are interested in. We assume that at the highest of
these spikes the microprocessor was executing the the first round of the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>
algorithm. The memory state based power model we created should match the
pattern of the actual power consumption at that specific point.</p>
<p>Just looking at the results, our assumption was most probably correct.</p>
<h1 id="automatically-cracking-an-entire-key"><a class="header" href="#automatically-cracking-an-entire-key">Automatically cracking an entire key</a></h1>
<p>In this chapter we are going to expand upon the <a href="aes/./manual-analysis.html">Manual
Analysis</a> chapter to make the process automatic and work
on the entire key. Most of what is discussed in this chapter is quite trivial.
If you feel quite comfortable with what was discussed in the previous chapters,
by all means skip this chapter and attempt to implement it yourself. If you get
stuck, you can always come here to get a hint.</p>
<h2 id="where-were-we"><a class="header" href="#where-were-we">Where were we?</a></h2>
<p>At the moment we have code for modeling the <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> memory based power state,
creating <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>s and a piece to plot the results.</p>
<pre><code class="language-python">import numpy as np
from tqdm import trange

# Modeling the power consumption
########################################
# Hamming Weight
HammingWeightFn = lambda x: bin(x).count('1')
HammingDistanceFn = lambda x, y: HammingWeightFn(x ^ y)

# ... prev ...

# Precompute Hamming Weight and Hamming Distance for bytes
HammingWeight = [ HammingWeightFn(n) for n in range (0x00, 0xff + 1) ] 
HammingDistance = [
    [ HammingDistanceFn(x, y) for x in range(0x00, 0xff + 1) ]
        for y in range(0x00, 0xff + 1)
]

# Rijndael Substitution box
SBox = [
    # 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, # 0
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, # 1
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, # 2
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, # 3
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, # 4
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, # 5
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, # 6
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, # 7
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, # 8
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, # 9
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, # a
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, # b
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, # c
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, # d
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, # e
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  # f
]

def hypothetical_power_usage(subkey, plain_text_char):

    # Use the Hamming Weight power usage model
    return HammingWeight[

        # Do a SBox look up of the XOR-ed value
        #
        # Since the Hamming Weight of the SBox value will
        # persist for longer in memory this will make finding the
        # pattern easier. It is also still before the Row Shifting
        # so it doesn't cause trouble.
        SBox [

            # The initial round key XOR-ed with the plain text
            subkey ^ plain_text_char
        ]
    ]
########################################

# Loading our trace data
########################################
import numpy as np

traces = np.load('output/traces.npy')
textins = np.load('output/textins.npy')

num_traces = np.shape(traces)[0]
num_points = np.shape(traces)[1]

########################################

# Pearson correlation
########################################
def covariance(X, Y):
    if len(X) != len(Y):
        print(&quot;Lengths are unequal, quiting...&quot;)
        quit()

    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)
    mean_y = np.mean(Y, dtype=np.float64)

    return np.sum((X - mean_x) * (Y - mean_y)) / n

def standard_deviation(X):
    n = len(X)
    mean_x = np.mean(X, dtype=np.float64)

    return np.sqrt( np.sum( np.power( (X - mean_x), 2 ) ) / n )

def pearson_correlation_coefficient(X, Y):
    cov = covariance(X, Y)
    sd_x = standard_deviation(X)
    sd_y = standard_deviation(Y)

    return cov / ( sd_x * sd_y ) 
########################################

# Define a function to calculate the Correlation Coefficients for a byte in a
# subkey.
########################################
def calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = pearson_correlation_coefficient(
            hypothetical_power,

            # Look at the individual traces points for every trace
            traces[:, point_index]
        )

    return point_correlation
########################################

# Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Plotting the max_correlation_coefficients
########################################
import matplotlib.pyplot as plt

plt.plot(max_correlation_coefficients)
plt.show()
########################################
</code></pre>
<h2 id="automatically-picking-the-best-subkey-guess"><a class="header" href="#automatically-picking-the-best-subkey-guess">Automatically picking the best subkey guess</a></h2>
<p>At the moment we plot the graph of the maximum <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>s and we
determine from there what is the correct option. We can easily automate this
using the observation that the correct option has the highest <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation
coefficient</a>. For this we can use the <a href="https://numpy.org/doc/stable/reference/generated/numpy.argmax.html">numpy
<code>argmax</code></a>
function.</p>
<p>Replace the code for plotting with the following code.</p>
<pre><code class="language-python"># Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex value and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
</code></pre>
<p>Now the code will automatically print out the option with the highest
<a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>.</p>
<blockquote>
<p><em>Note:</em> If we have done only a few traces and our correlation coefficients are
a bit less reliable, we can use
<a href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html?highlight=argsort#numpy.argsort"><code>np.argsort(...)[::-1]</code></a>
to select multiple options. With this we can, for example, try to brute force
with the top 5.</p>
</blockquote>
<h2 id="cracking-an-entire-key"><a class="header" href="#cracking-an-entire-key">Cracking an entire key</a></h2>
<p>In order for us to crack the entire key, we can just add another <code>for</code> loop.
This loop will go through all sub-keys.</p>
<p>This will turn the first following code into the second piece of code.</p>
<pre><code class="language-python"># Looping through all possible bytes
########################################
# Save all correlation coefficients
max_correlation_coefficients = np.zeros(256)

# Loop through values this subkey
for subkey in trange(0xff + 1, desc=&quot;Attack Subkey&quot;):
    max_correlation_coefficients[subkey] = max(abs(
        calculate_correlation_coefficients(subkey, 0)
    ))
########################################

# Printing the best guess
########################################
# Select the element with the highest correlation
best_guess = np.argmax(max_correlation_coefficients)

# Print both the hex value and the ASCII character
print(&quot;Best guess: {:02x} or '{}'&quot;.format(best_guess, chr(best_guess)))
########################################
</code></pre>
<pre><code class="language-python"># Looping through all subkeys
########################################
# The eventual key guess
best_guess = np.zeros(16)

# Loop through all possible subkeys
for subkey_index in trange(16, desc=&quot;Subkey Index&quot;):
    # Save all correlation coefficients
    max_correlation_coefficients = np.zeros(256)

    # Loop through values this subkey
    for subkey in range(0x00, 0xff + 1):
        max_correlation_coefficients[subkey] = max(abs(
            calculate_correlation_coefficients(subkey, subkey_index)
        ))
    
    # Save the best guess
    best_guess[subkey_index] = np.argmax(max_correlation_coefficients)
########################################

# Printing the best guess
########################################
print(&quot;Best guess:&quot;)
for b in best_guess: print(&quot;{:02x} &quot;.format(int(b)), end=&quot;&quot;)
print(&quot;&quot;)
for b in best_guess: print(&quot;{}&quot;.format(chr(int(b))), end=&quot;&quot;)
print(&quot;&quot;)
########################################
</code></pre>
<blockquote>
<p><em>Note:</em> Our code is not very efficient and thus is might take quite a
bit of time for it to crack entire key.</p>
</blockquote>
<p>This should output the following.</p>
<pre><code class="language-text">Best guess:
48 34 63 6b 33 72 6d 34 6e 2d 6c 33 33 74 34 32
H4ck3rm4n-l33t42
</code></pre>
<h1 id="sidenote-optimizing-our-algorithm"><a class="header" href="#sidenote-optimizing-our-algorithm">Sidenote: Optimizing our algorithm</a></h1>
<p>As you may have noticed our algorithm is now really slow. This is due to the
calculation of <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">Pearson Correlation Coefficient</a>s. We can speed this up by a lot
if we notice a couple of things.</p>
<ol>
<li>\(\sqrt{a}\sqrt{b}=\sqrt{a b}\). Since square rooting is a very expensive
operation, we can optimize the calculation of \(\sigma_x \sigma_y\) from
two square root calculations to one.</li>
<li>We are recalculating a lot of averages and standard deviations. We can
precompute these averages and <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>s and them fetch them instead
of recomputing them.</li>
<li>Since we only care about the maximum <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a> and have no
interest in the value itself, we can stop doing any factorization.</li>
</ol>
<p>In the following code we have created a function which applies these three
optimized functions when calculating the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">correlation coefficient</a>s.</p>
<pre><code class="language-python">point_means = np.mean(traces, axis=0, dtype=np.float64)
point_mean_diff = traces - point_means

point_mean_diff_squared_sum = np.sum(np.power(point_mean_diff, 2), axis=0)

def optimized_calculate_correlation_coefficients(subkey, subkey_index):
    # Declare a numpy for the hypothetical power usage
    hypothetical_power = np.zeros(num_traces)

    for trace_index in range(0, num_traces):
        hypothetical_power[trace_index] = hypothetical_power_usage(
            subkey,
            textins[trace_index][subkey_index]
        )

    hypothetical_power_mean = np.mean(hypothetical_power, dtype=np.float64)
    hypothetical_power_mean_diff = hypothetical_power - hypothetical_power_mean

    hypothetical_power_mean_diff_sum_squared = np.sum(
        np.power(hypothetical_power_mean_diff, 2)
    )

    # We are going to the determine correlations between each trace point
    # and the hypothetical power usage. This will save all those coefficients
    point_correlation = np.zeros(num_points)

    # Loop through all points and determine their correlation coefficients
    for point_index in range(0, num_points):
        point_correlation[point_index] = np.sum(
            hypothetical_power_mean_diff *

            # Look at the individual traces points for every trace
            point_mean_diff[:, point_index]
        ) / np.sqrt(hypothetical_power_mean_diff_sum_squared *
                point_mean_diff_squared_sum[point_index])

    return point_correlation
</code></pre>
<h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<blockquote>
<p><em>Note:</em> These are not yet fininished.</p>
</blockquote>
<ol>
<li>At the following
<a href="https://github.com/coastalwhite/intro-power-analysis/tree/main/datasets/aes">location</a>
you can find 3 sets of power traces, can you crack their keys used? You will
know when you cracked them.</li>
<li>Does the method of statistical analysis apply to the <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha
ciphers</a>. Why does it work? Why does
it not work?</li>
<li>Crack the secret key used for the following ChaCha power trace. The source
code of which can be found <a href="https://githu.com/coastalwhite/cw-chacha">here</a>.
<strong>TODO: HAS TO BE ADDED</strong></li>
</ol>
<h1 id="assignment"><a class="header" href="#assignment">Assignment</a></h1>
<p>As a final assignment for this walkthrough, there should detailed report on some
component of power analysis including a demonstration and what effect it has on
possible attack vectors. A few categories of what we can look at along with some
example topics:</p>
<ul>
<li>Breaking an encryption algorithm which is not demonstrated in this walkthrough.
Possibly combined with some protections against power analysis. Have a look at
the <a href="./preparing/toolchains.html">Compiling your own algorithms</a> instructions.
Some examples of interesting algorithms are:
<ul>
<li>Breaking the <a href="https://en.wikipedia.org/wiki/Curve25519">Ed25519</a>
algorithm and providing some protections against power analysis. (Have a look
at the <a href="https://github.com/orlp/ed25519">following implementation</a>)</li>
<li>Breaking <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha</a> stream ciphers and
providing some protections against power analysis. (Have a look at the
<a href="https://www.oryx-embedded.com/doc/chacha_8c_source.html">following implementation</a>)</li>
</ul>
</li>
<li>Providing multiple protections on <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> or <a href="https://nl.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> along with analysis of their
effectiveness and remaining attack vectors.</li>
<li>Breaking algorithms by using the data power analysis provides us in new ways.
<ul>
<li>Apply machine learning to the data provides by a power-trace of an
encryption algorithm and determine its effectiveness.</li>
<li>Look further into optimizing the amount traces needed to do a correlation
power analysis attack. How many traces can reliably crack a certain
algorithm? Can this be improved in some way?</li>
</ul>
</li>
</ul>
<p>These are just a few examples within the many possible topics. If another
creative idea pops up, feel free to give it a shot. The only requirements of the
report are a <strong>reproducible demonstration and explanation of your method</strong> and a
<strong>description of (remaining) attack vectors through power analysis</strong>.</p>
<h2 id="grading--what-will-be-looked-at"><a class="header" href="#grading--what-will-be-looked-at">Grading / What will be looked at</a></h2>
<p>There are a few important topics to which is going to be payed attention whilst
grading.</p>
<h3 id="complexity-and-creativity-of-method"><a class="header" href="#complexity-and-creativity-of-method">Complexity and creativity of method</a></h3>
<p>Most important is the complexity and creativity of your method. These are best
formulated by the following two questions:</p>
<ol>
<li>What level of difficulty is your attack vector or method of execution?</li>
<li>How much of this method was already pre-done by other people?</li>
</ol>
<p>This also leads to the point that <strong>it is very important to cite sources for
your attacks.</strong> Any found plagiarism will <strong>not</strong> be tolerated. If one uses a
piece of text, code or method (almost) directly copied or cited from a source,
cite that (primary) source. If one adapts a piece of text, code or method from a
source, cite as <code>Adapted from ...</code>.</p>
<h3 id="level-of-explanation-and-writing"><a class="header" href="#level-of-explanation-and-writing">Level of explanation and writing</a></h3>
<p>Apart from having a great and creative method, it is also very important to make
clear why and why your method was so great and creative. Go into depth on the
steps of your method and why those steps help reach the desired result. You can
assume that the reader has also followed this walkthrough and albeit has some
preliminary knowledge.</p>
<h3 id="reproducibility"><a class="header" href="#reproducibility">Reproducibility</a></h3>
<p>The final important part of your assignment on <a href="https://en.wikipedia.org/wiki/Power_analysis">power analysis</a> is going to be
reproducibility.  How easy is it for the people checking your assignment to
reproduce your method(/results). Is your code readable? Is there some clear
documentation on compiling code, executing an attack or installing dependencies?
It is not needed to write step by step instructions yourself for most of these
steps, but it is important to write an overview on installing dependencies
(linking to the installation guide of that dependency), compiling instructions
(when needed) and attack execution instructions.</p>
<p>Good luck and have fun!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
